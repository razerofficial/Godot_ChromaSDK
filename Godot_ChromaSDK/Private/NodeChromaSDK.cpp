#include "../Public/NodeChromaSDK.h"
#include "../Public/ChromaAnimationAPI.h"
#include <stdio.h>
#include <string>

using namespace godot;
using namespace ChromaSDK;

void NodeChromaSDK::_register_methods() {
	register_method((char*)"IsAPIInitialized", &NodeChromaSDK::IsAPIInitialized);
#pragma region autogenerated
	//register_method((char*)"AddFrame", &NodeChromaSDK::AddFrame);
	register_method((char*)"AddNonZeroAllKeysAllFrames", &NodeChromaSDK::AddNonZeroAllKeysAllFrames);
	register_method((char*)"AddNonZeroAllKeysAllFramesName", &NodeChromaSDK::AddNonZeroAllKeysAllFramesName);
	register_method((char*)"AddNonZeroAllKeysAllFramesNameD", &NodeChromaSDK::AddNonZeroAllKeysAllFramesNameD);
	register_method((char*)"AddNonZeroAllKeysAllFramesOffset", &NodeChromaSDK::AddNonZeroAllKeysAllFramesOffset);
	register_method((char*)"AddNonZeroAllKeysAllFramesOffsetName", &NodeChromaSDK::AddNonZeroAllKeysAllFramesOffsetName);
	register_method((char*)"AddNonZeroAllKeysAllFramesOffsetNameD", &NodeChromaSDK::AddNonZeroAllKeysAllFramesOffsetNameD);
	register_method((char*)"AddNonZeroAllKeysOffset", &NodeChromaSDK::AddNonZeroAllKeysOffset);
	register_method((char*)"AddNonZeroAllKeysOffsetName", &NodeChromaSDK::AddNonZeroAllKeysOffsetName);
	register_method((char*)"AddNonZeroAllKeysOffsetNameD", &NodeChromaSDK::AddNonZeroAllKeysOffsetNameD);
	register_method((char*)"AddNonZeroTargetAllKeysAllFrames", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFrames);
	register_method((char*)"AddNonZeroTargetAllKeysAllFramesName", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesName);
	register_method((char*)"AddNonZeroTargetAllKeysAllFramesNameD", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesNameD);
	register_method((char*)"AddNonZeroTargetAllKeysAllFramesOffset", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffset);
	register_method((char*)"AddNonZeroTargetAllKeysAllFramesOffsetName", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffsetName);
	register_method((char*)"AddNonZeroTargetAllKeysAllFramesOffsetNameD", &NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffsetNameD);
	register_method((char*)"AddNonZeroTargetAllKeysOffset", &NodeChromaSDK::AddNonZeroTargetAllKeysOffset);
	register_method((char*)"AddNonZeroTargetAllKeysOffsetName", &NodeChromaSDK::AddNonZeroTargetAllKeysOffsetName);
	register_method((char*)"AddNonZeroTargetAllKeysOffsetNameD", &NodeChromaSDK::AddNonZeroTargetAllKeysOffsetNameD);
	register_method((char*)"AppendAllFrames", &NodeChromaSDK::AppendAllFrames);
	register_method((char*)"AppendAllFramesName", &NodeChromaSDK::AppendAllFramesName);
	register_method((char*)"AppendAllFramesNameD", &NodeChromaSDK::AppendAllFramesNameD);
	register_method((char*)"ClearAll", &NodeChromaSDK::ClearAll);
	register_method((char*)"ClearAnimationType", &NodeChromaSDK::ClearAnimationType);
	register_method((char*)"CloseAll", &NodeChromaSDK::CloseAll);
	register_method((char*)"CloseAnimation", &NodeChromaSDK::CloseAnimation);
	register_method((char*)"CloseAnimationD", &NodeChromaSDK::CloseAnimationD);
	register_method((char*)"CloseAnimationName", &NodeChromaSDK::CloseAnimationName);
	register_method((char*)"CloseAnimationNameD", &NodeChromaSDK::CloseAnimationNameD);
	register_method((char*)"CloseComposite", &NodeChromaSDK::CloseComposite);
	register_method((char*)"CloseCompositeD", &NodeChromaSDK::CloseCompositeD);
	register_method((char*)"CopyAnimation", &NodeChromaSDK::CopyAnimation);
	register_method((char*)"CopyAnimationName", &NodeChromaSDK::CopyAnimationName);
	register_method((char*)"CopyAnimationNameD", &NodeChromaSDK::CopyAnimationNameD);
	register_method((char*)"CopyBlueChannelAllFrames", &NodeChromaSDK::CopyBlueChannelAllFrames);
	register_method((char*)"CopyBlueChannelAllFramesName", &NodeChromaSDK::CopyBlueChannelAllFramesName);
	register_method((char*)"CopyBlueChannelAllFramesNameD", &NodeChromaSDK::CopyBlueChannelAllFramesNameD);
	register_method((char*)"CopyGreenChannelAllFrames", &NodeChromaSDK::CopyGreenChannelAllFrames);
	register_method((char*)"CopyGreenChannelAllFramesName", &NodeChromaSDK::CopyGreenChannelAllFramesName);
	register_method((char*)"CopyGreenChannelAllFramesNameD", &NodeChromaSDK::CopyGreenChannelAllFramesNameD);
	register_method((char*)"CopyKeyColor", &NodeChromaSDK::CopyKeyColor);
	register_method((char*)"CopyKeyColorAllFrames", &NodeChromaSDK::CopyKeyColorAllFrames);
	register_method((char*)"CopyKeyColorAllFramesName", &NodeChromaSDK::CopyKeyColorAllFramesName);
	register_method((char*)"CopyKeyColorAllFramesNameD", &NodeChromaSDK::CopyKeyColorAllFramesNameD);
	register_method((char*)"CopyKeyColorAllFramesOffset", &NodeChromaSDK::CopyKeyColorAllFramesOffset);
	register_method((char*)"CopyKeyColorAllFramesOffsetName", &NodeChromaSDK::CopyKeyColorAllFramesOffsetName);
	register_method((char*)"CopyKeyColorAllFramesOffsetNameD", &NodeChromaSDK::CopyKeyColorAllFramesOffsetNameD);
	register_method((char*)"CopyKeyColorName", &NodeChromaSDK::CopyKeyColorName);
	register_method((char*)"CopyKeyColorNameD", &NodeChromaSDK::CopyKeyColorNameD);
	register_method((char*)"CopyKeysColor", &NodeChromaSDK::CopyKeysColor);
	register_method((char*)"CopyKeysColorAllFrames", &NodeChromaSDK::CopyKeysColorAllFrames);
	register_method((char*)"CopyKeysColorAllFramesName", &NodeChromaSDK::CopyKeysColorAllFramesName);
	register_method((char*)"CopyKeysColorName", &NodeChromaSDK::CopyKeysColorName);
	register_method((char*)"CopyKeysColorOffset", &NodeChromaSDK::CopyKeysColorOffset);
	register_method((char*)"CopyKeysColorOffsetName", &NodeChromaSDK::CopyKeysColorOffsetName);
	register_method((char*)"CopyNonZeroAllKeys", &NodeChromaSDK::CopyNonZeroAllKeys);
	register_method((char*)"CopyNonZeroAllKeysAllFrames", &NodeChromaSDK::CopyNonZeroAllKeysAllFrames);
	register_method((char*)"CopyNonZeroAllKeysAllFramesName", &NodeChromaSDK::CopyNonZeroAllKeysAllFramesName);
	register_method((char*)"CopyNonZeroAllKeysAllFramesNameD", &NodeChromaSDK::CopyNonZeroAllKeysAllFramesNameD);
	register_method((char*)"CopyNonZeroAllKeysAllFramesOffset", &NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffset);
	register_method((char*)"CopyNonZeroAllKeysAllFramesOffsetName", &NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffsetName);
	register_method((char*)"CopyNonZeroAllKeysAllFramesOffsetNameD", &NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffsetNameD);
	register_method((char*)"CopyNonZeroAllKeysName", &NodeChromaSDK::CopyNonZeroAllKeysName);
	register_method((char*)"CopyNonZeroAllKeysNameD", &NodeChromaSDK::CopyNonZeroAllKeysNameD);
	register_method((char*)"CopyNonZeroAllKeysOffset", &NodeChromaSDK::CopyNonZeroAllKeysOffset);
	register_method((char*)"CopyNonZeroAllKeysOffsetName", &NodeChromaSDK::CopyNonZeroAllKeysOffsetName);
	register_method((char*)"CopyNonZeroAllKeysOffsetNameD", &NodeChromaSDK::CopyNonZeroAllKeysOffsetNameD);
	register_method((char*)"CopyNonZeroKeyColor", &NodeChromaSDK::CopyNonZeroKeyColor);
	register_method((char*)"CopyNonZeroKeyColorName", &NodeChromaSDK::CopyNonZeroKeyColorName);
	register_method((char*)"CopyNonZeroKeyColorNameD", &NodeChromaSDK::CopyNonZeroKeyColorNameD);
	register_method((char*)"CopyNonZeroTargetAllKeys", &NodeChromaSDK::CopyNonZeroTargetAllKeys);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFrames", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFrames);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFramesName", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesName);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFramesNameD", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesNameD);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFramesOffset", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffset);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFramesOffsetName", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffsetName);
	register_method((char*)"CopyNonZeroTargetAllKeysAllFramesOffsetNameD", &NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffsetNameD);
	register_method((char*)"CopyNonZeroTargetAllKeysName", &NodeChromaSDK::CopyNonZeroTargetAllKeysName);
	register_method((char*)"CopyNonZeroTargetAllKeysNameD", &NodeChromaSDK::CopyNonZeroTargetAllKeysNameD);
	register_method((char*)"CopyNonZeroTargetAllKeysOffset", &NodeChromaSDK::CopyNonZeroTargetAllKeysOffset);
	register_method((char*)"CopyNonZeroTargetAllKeysOffsetName", &NodeChromaSDK::CopyNonZeroTargetAllKeysOffsetName);
	register_method((char*)"CopyNonZeroTargetAllKeysOffsetNameD", &NodeChromaSDK::CopyNonZeroTargetAllKeysOffsetNameD);
	register_method((char*)"CopyNonZeroTargetZeroAllKeysAllFrames", &NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFrames);
	register_method((char*)"CopyNonZeroTargetZeroAllKeysAllFramesName", &NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFramesName);
	register_method((char*)"CopyNonZeroTargetZeroAllKeysAllFramesNameD", &NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFramesNameD);
	register_method((char*)"CopyRedChannelAllFrames", &NodeChromaSDK::CopyRedChannelAllFrames);
	register_method((char*)"CopyRedChannelAllFramesName", &NodeChromaSDK::CopyRedChannelAllFramesName);
	register_method((char*)"CopyRedChannelAllFramesNameD", &NodeChromaSDK::CopyRedChannelAllFramesNameD);
	register_method((char*)"CopyZeroAllKeysAllFrames", &NodeChromaSDK::CopyZeroAllKeysAllFrames);
	register_method((char*)"CopyZeroAllKeysAllFramesName", &NodeChromaSDK::CopyZeroAllKeysAllFramesName);
	register_method((char*)"CopyZeroAllKeysAllFramesNameD", &NodeChromaSDK::CopyZeroAllKeysAllFramesNameD);
	register_method((char*)"CopyZeroAllKeysAllFramesOffset", &NodeChromaSDK::CopyZeroAllKeysAllFramesOffset);
	register_method((char*)"CopyZeroAllKeysAllFramesOffsetName", &NodeChromaSDK::CopyZeroAllKeysAllFramesOffsetName);
	register_method((char*)"CopyZeroAllKeysAllFramesOffsetNameD", &NodeChromaSDK::CopyZeroAllKeysAllFramesOffsetNameD);
	register_method((char*)"CopyZeroKeyColor", &NodeChromaSDK::CopyZeroKeyColor);
	register_method((char*)"CopyZeroKeyColorName", &NodeChromaSDK::CopyZeroKeyColorName);
	register_method((char*)"CopyZeroKeyColorNameD", &NodeChromaSDK::CopyZeroKeyColorNameD);
	register_method((char*)"CopyZeroTargetAllKeysAllFrames", &NodeChromaSDK::CopyZeroTargetAllKeysAllFrames);
	register_method((char*)"CopyZeroTargetAllKeysAllFramesName", &NodeChromaSDK::CopyZeroTargetAllKeysAllFramesName);
	register_method((char*)"CopyZeroTargetAllKeysAllFramesNameD", &NodeChromaSDK::CopyZeroTargetAllKeysAllFramesNameD);
	//register_method((char*)"CoreCreateChromaLinkEffect", &NodeChromaSDK::CoreCreateChromaLinkEffect);
	//register_method((char*)"CoreCreateEffect", &NodeChromaSDK::CoreCreateEffect);
	//register_method((char*)"CoreCreateHeadsetEffect", &NodeChromaSDK::CoreCreateHeadsetEffect);
	//register_method((char*)"CoreCreateKeyboardEffect", &NodeChromaSDK::CoreCreateKeyboardEffect);
	//register_method((char*)"CoreCreateKeypadEffect", &NodeChromaSDK::CoreCreateKeypadEffect);
	//register_method((char*)"CoreCreateMouseEffect", &NodeChromaSDK::CoreCreateMouseEffect);
	//register_method((char*)"CoreCreateMousepadEffect", &NodeChromaSDK::CoreCreateMousepadEffect);
	//register_method((char*)"CoreDeleteEffect", &NodeChromaSDK::CoreDeleteEffect);
	register_method((char*)"CoreInit", &NodeChromaSDK::CoreInit);
	//register_method((char*)"CoreQueryDevice", &NodeChromaSDK::CoreQueryDevice);
	//register_method((char*)"CoreSetEffect", &NodeChromaSDK::CoreSetEffect);
	register_method((char*)"CoreUnInit", &NodeChromaSDK::CoreUnInit);
	register_method((char*)"CreateAnimation", &NodeChromaSDK::CreateAnimation);
	register_method((char*)"CreateAnimationInMemory", &NodeChromaSDK::CreateAnimationInMemory);
	//register_method((char*)"CreateEffect", &NodeChromaSDK::CreateEffect);
	//register_method((char*)"DeleteEffect", &NodeChromaSDK::DeleteEffect);
	register_method((char*)"DuplicateFirstFrame", &NodeChromaSDK::DuplicateFirstFrame);
	register_method((char*)"DuplicateFirstFrameName", &NodeChromaSDK::DuplicateFirstFrameName);
	register_method((char*)"DuplicateFirstFrameNameD", &NodeChromaSDK::DuplicateFirstFrameNameD);
	register_method((char*)"DuplicateFrames", &NodeChromaSDK::DuplicateFrames);
	register_method((char*)"DuplicateFramesName", &NodeChromaSDK::DuplicateFramesName);
	register_method((char*)"DuplicateFramesNameD", &NodeChromaSDK::DuplicateFramesNameD);
	register_method((char*)"DuplicateMirrorFrames", &NodeChromaSDK::DuplicateMirrorFrames);
	register_method((char*)"DuplicateMirrorFramesName", &NodeChromaSDK::DuplicateMirrorFramesName);
	register_method((char*)"DuplicateMirrorFramesNameD", &NodeChromaSDK::DuplicateMirrorFramesNameD);
	register_method((char*)"FadeEndFrames", &NodeChromaSDK::FadeEndFrames);
	register_method((char*)"FadeEndFramesName", &NodeChromaSDK::FadeEndFramesName);
	register_method((char*)"FadeEndFramesNameD", &NodeChromaSDK::FadeEndFramesNameD);
	register_method((char*)"FadeStartFrames", &NodeChromaSDK::FadeStartFrames);
	register_method((char*)"FadeStartFramesName", &NodeChromaSDK::FadeStartFramesName);
	register_method((char*)"FadeStartFramesNameD", &NodeChromaSDK::FadeStartFramesNameD);
	register_method((char*)"FillColor", &NodeChromaSDK::FillColor);
	register_method((char*)"FillColorAllFrames", &NodeChromaSDK::FillColorAllFrames);
	register_method((char*)"FillColorAllFramesName", &NodeChromaSDK::FillColorAllFramesName);
	register_method((char*)"FillColorAllFramesNameD", &NodeChromaSDK::FillColorAllFramesNameD);
	register_method((char*)"FillColorAllFramesRGB", &NodeChromaSDK::FillColorAllFramesRGB);
	register_method((char*)"FillColorAllFramesRGBName", &NodeChromaSDK::FillColorAllFramesRGBName);
	register_method((char*)"FillColorAllFramesRGBNameD", &NodeChromaSDK::FillColorAllFramesRGBNameD);
	register_method((char*)"FillColorName", &NodeChromaSDK::FillColorName);
	register_method((char*)"FillColorNameD", &NodeChromaSDK::FillColorNameD);
	register_method((char*)"FillColorRGB", &NodeChromaSDK::FillColorRGB);
	register_method((char*)"FillColorRGBName", &NodeChromaSDK::FillColorRGBName);
	register_method((char*)"FillColorRGBNameD", &NodeChromaSDK::FillColorRGBNameD);
	register_method((char*)"FillNonZeroColor", &NodeChromaSDK::FillNonZeroColor);
	register_method((char*)"FillNonZeroColorAllFrames", &NodeChromaSDK::FillNonZeroColorAllFrames);
	register_method((char*)"FillNonZeroColorAllFramesName", &NodeChromaSDK::FillNonZeroColorAllFramesName);
	register_method((char*)"FillNonZeroColorAllFramesNameD", &NodeChromaSDK::FillNonZeroColorAllFramesNameD);
	register_method((char*)"FillNonZeroColorAllFramesRGB", &NodeChromaSDK::FillNonZeroColorAllFramesRGB);
	register_method((char*)"FillNonZeroColorAllFramesRGBName", &NodeChromaSDK::FillNonZeroColorAllFramesRGBName);
	register_method((char*)"FillNonZeroColorAllFramesRGBNameD", &NodeChromaSDK::FillNonZeroColorAllFramesRGBNameD);
	register_method((char*)"FillNonZeroColorName", &NodeChromaSDK::FillNonZeroColorName);
	register_method((char*)"FillNonZeroColorNameD", &NodeChromaSDK::FillNonZeroColorNameD);
	register_method((char*)"FillNonZeroColorRGB", &NodeChromaSDK::FillNonZeroColorRGB);
	register_method((char*)"FillNonZeroColorRGBName", &NodeChromaSDK::FillNonZeroColorRGBName);
	register_method((char*)"FillNonZeroColorRGBNameD", &NodeChromaSDK::FillNonZeroColorRGBNameD);
	register_method((char*)"FillRandomColors", &NodeChromaSDK::FillRandomColors);
	register_method((char*)"FillRandomColorsAllFrames", &NodeChromaSDK::FillRandomColorsAllFrames);
	register_method((char*)"FillRandomColorsAllFramesName", &NodeChromaSDK::FillRandomColorsAllFramesName);
	register_method((char*)"FillRandomColorsAllFramesNameD", &NodeChromaSDK::FillRandomColorsAllFramesNameD);
	register_method((char*)"FillRandomColorsBlackAndWhite", &NodeChromaSDK::FillRandomColorsBlackAndWhite);
	register_method((char*)"FillRandomColorsBlackAndWhiteAllFrames", &NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFrames);
	register_method((char*)"FillRandomColorsBlackAndWhiteAllFramesName", &NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFramesName);
	register_method((char*)"FillRandomColorsBlackAndWhiteAllFramesNameD", &NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFramesNameD);
	register_method((char*)"FillRandomColorsBlackAndWhiteName", &NodeChromaSDK::FillRandomColorsBlackAndWhiteName);
	register_method((char*)"FillRandomColorsBlackAndWhiteNameD", &NodeChromaSDK::FillRandomColorsBlackAndWhiteNameD);
	register_method((char*)"FillRandomColorsName", &NodeChromaSDK::FillRandomColorsName);
	register_method((char*)"FillRandomColorsNameD", &NodeChromaSDK::FillRandomColorsNameD);
	register_method((char*)"FillThresholdColors", &NodeChromaSDK::FillThresholdColors);
	register_method((char*)"FillThresholdColorsAllFrames", &NodeChromaSDK::FillThresholdColorsAllFrames);
	register_method((char*)"FillThresholdColorsAllFramesName", &NodeChromaSDK::FillThresholdColorsAllFramesName);
	register_method((char*)"FillThresholdColorsAllFramesNameD", &NodeChromaSDK::FillThresholdColorsAllFramesNameD);
	register_method((char*)"FillThresholdColorsAllFramesRGB", &NodeChromaSDK::FillThresholdColorsAllFramesRGB);
	register_method((char*)"FillThresholdColorsAllFramesRGBName", &NodeChromaSDK::FillThresholdColorsAllFramesRGBName);
	register_method((char*)"FillThresholdColorsAllFramesRGBNameD", &NodeChromaSDK::FillThresholdColorsAllFramesRGBNameD);
	register_method((char*)"FillThresholdColorsMinMaxAllFramesRGB", &NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGB);
	register_method((char*)"FillThresholdColorsMinMaxAllFramesRGBName", &NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGBName);
	register_method((char*)"FillThresholdColorsMinMaxAllFramesRGBNameD", &NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGBNameD);
	register_method((char*)"FillThresholdColorsMinMaxRGB", &NodeChromaSDK::FillThresholdColorsMinMaxRGB);
	register_method((char*)"FillThresholdColorsMinMaxRGBName", &NodeChromaSDK::FillThresholdColorsMinMaxRGBName);
	register_method((char*)"FillThresholdColorsMinMaxRGBNameD", &NodeChromaSDK::FillThresholdColorsMinMaxRGBNameD);
	register_method((char*)"FillThresholdColorsName", &NodeChromaSDK::FillThresholdColorsName);
	register_method((char*)"FillThresholdColorsNameD", &NodeChromaSDK::FillThresholdColorsNameD);
	register_method((char*)"FillThresholdColorsRGB", &NodeChromaSDK::FillThresholdColorsRGB);
	register_method((char*)"FillThresholdColorsRGBName", &NodeChromaSDK::FillThresholdColorsRGBName);
	register_method((char*)"FillThresholdColorsRGBNameD", &NodeChromaSDK::FillThresholdColorsRGBNameD);
	register_method((char*)"FillThresholdRGBColorsAllFramesRGB", &NodeChromaSDK::FillThresholdRGBColorsAllFramesRGB);
	register_method((char*)"FillThresholdRGBColorsAllFramesRGBName", &NodeChromaSDK::FillThresholdRGBColorsAllFramesRGBName);
	register_method((char*)"FillThresholdRGBColorsAllFramesRGBNameD", &NodeChromaSDK::FillThresholdRGBColorsAllFramesRGBNameD);
	register_method((char*)"FillThresholdRGBColorsRGB", &NodeChromaSDK::FillThresholdRGBColorsRGB);
	register_method((char*)"FillThresholdRGBColorsRGBName", &NodeChromaSDK::FillThresholdRGBColorsRGBName);
	register_method((char*)"FillThresholdRGBColorsRGBNameD", &NodeChromaSDK::FillThresholdRGBColorsRGBNameD);
	register_method((char*)"FillZeroColor", &NodeChromaSDK::FillZeroColor);
	register_method((char*)"FillZeroColorAllFrames", &NodeChromaSDK::FillZeroColorAllFrames);
	register_method((char*)"FillZeroColorAllFramesName", &NodeChromaSDK::FillZeroColorAllFramesName);
	register_method((char*)"FillZeroColorAllFramesNameD", &NodeChromaSDK::FillZeroColorAllFramesNameD);
	register_method((char*)"FillZeroColorAllFramesRGB", &NodeChromaSDK::FillZeroColorAllFramesRGB);
	register_method((char*)"FillZeroColorAllFramesRGBName", &NodeChromaSDK::FillZeroColorAllFramesRGBName);
	register_method((char*)"FillZeroColorAllFramesRGBNameD", &NodeChromaSDK::FillZeroColorAllFramesRGBNameD);
	register_method((char*)"FillZeroColorName", &NodeChromaSDK::FillZeroColorName);
	register_method((char*)"FillZeroColorNameD", &NodeChromaSDK::FillZeroColorNameD);
	register_method((char*)"FillZeroColorRGB", &NodeChromaSDK::FillZeroColorRGB);
	register_method((char*)"FillZeroColorRGBName", &NodeChromaSDK::FillZeroColorRGBName);
	register_method((char*)"FillZeroColorRGBNameD", &NodeChromaSDK::FillZeroColorRGBNameD);
	register_method((char*)"Get1DColor", &NodeChromaSDK::Get1DColor);
	register_method((char*)"Get1DColorName", &NodeChromaSDK::Get1DColorName);
	register_method((char*)"Get1DColorNameD", &NodeChromaSDK::Get1DColorNameD);
	register_method((char*)"Get2DColor", &NodeChromaSDK::Get2DColor);
	register_method((char*)"Get2DColorName", &NodeChromaSDK::Get2DColorName);
	register_method((char*)"Get2DColorNameD", &NodeChromaSDK::Get2DColorNameD);
	register_method((char*)"GetAnimation", &NodeChromaSDK::GetAnimation);
	register_method((char*)"GetAnimationCount", &NodeChromaSDK::GetAnimationCount);
	register_method((char*)"GetAnimationD", &NodeChromaSDK::GetAnimationD);
	register_method((char*)"GetAnimationId", &NodeChromaSDK::GetAnimationId);
	register_method((char*)"GetAnimationName", &NodeChromaSDK::GetAnimationName);
	register_method((char*)"GetCurrentFrame", &NodeChromaSDK::GetCurrentFrame);
	register_method((char*)"GetCurrentFrameName", &NodeChromaSDK::GetCurrentFrameName);
	register_method((char*)"GetCurrentFrameNameD", &NodeChromaSDK::GetCurrentFrameNameD);
	register_method((char*)"GetDevice", &NodeChromaSDK::GetDevice);
	register_method((char*)"GetDeviceName", &NodeChromaSDK::GetDeviceName);
	register_method((char*)"GetDeviceNameD", &NodeChromaSDK::GetDeviceNameD);
	register_method((char*)"GetDeviceType", &NodeChromaSDK::GetDeviceType);
	register_method((char*)"GetDeviceTypeName", &NodeChromaSDK::GetDeviceTypeName);
	register_method((char*)"GetDeviceTypeNameD", &NodeChromaSDK::GetDeviceTypeNameD);
	//register_method((char*)"GetFrame", &NodeChromaSDK::GetFrame);
	register_method((char*)"GetFrameCount", &NodeChromaSDK::GetFrameCount);
	register_method((char*)"GetFrameCountName", &NodeChromaSDK::GetFrameCountName);
	register_method((char*)"GetFrameCountNameD", &NodeChromaSDK::GetFrameCountNameD);
	register_method((char*)"GetKeyColor", &NodeChromaSDK::GetKeyColor);
	register_method((char*)"GetKeyColorD", &NodeChromaSDK::GetKeyColorD);
	register_method((char*)"GetKeyColorName", &NodeChromaSDK::GetKeyColorName);
	register_method((char*)"GetLibraryLoadedState", &NodeChromaSDK::GetLibraryLoadedState);
	register_method((char*)"GetLibraryLoadedStateD", &NodeChromaSDK::GetLibraryLoadedStateD);
	register_method((char*)"GetMaxColumn", &NodeChromaSDK::GetMaxColumn);
	register_method((char*)"GetMaxColumnD", &NodeChromaSDK::GetMaxColumnD);
	register_method((char*)"GetMaxLeds", &NodeChromaSDK::GetMaxLeds);
	register_method((char*)"GetMaxLedsD", &NodeChromaSDK::GetMaxLedsD);
	register_method((char*)"GetMaxRow", &NodeChromaSDK::GetMaxRow);
	register_method((char*)"GetMaxRowD", &NodeChromaSDK::GetMaxRowD);
	register_method((char*)"GetPlayingAnimationCount", &NodeChromaSDK::GetPlayingAnimationCount);
	register_method((char*)"GetPlayingAnimationId", &NodeChromaSDK::GetPlayingAnimationId);
	register_method((char*)"GetRGB", &NodeChromaSDK::GetRGB);
	register_method((char*)"GetRGBD", &NodeChromaSDK::GetRGBD);
	register_method((char*)"HasAnimationLoop", &NodeChromaSDK::HasAnimationLoop);
	register_method((char*)"HasAnimationLoopName", &NodeChromaSDK::HasAnimationLoopName);
	register_method((char*)"HasAnimationLoopNameD", &NodeChromaSDK::HasAnimationLoopNameD);
	register_method((char*)"Init", &NodeChromaSDK::Init);
	register_method((char*)"InitD", &NodeChromaSDK::InitD);
	register_method((char*)"InsertDelay", &NodeChromaSDK::InsertDelay);
	register_method((char*)"InsertDelayName", &NodeChromaSDK::InsertDelayName);
	register_method((char*)"InsertDelayNameD", &NodeChromaSDK::InsertDelayNameD);
	register_method((char*)"InsertFrame", &NodeChromaSDK::InsertFrame);
	register_method((char*)"InsertFrameName", &NodeChromaSDK::InsertFrameName);
	register_method((char*)"InsertFrameNameD", &NodeChromaSDK::InsertFrameNameD);
	register_method((char*)"InvertColors", &NodeChromaSDK::InvertColors);
	register_method((char*)"InvertColorsAllFrames", &NodeChromaSDK::InvertColorsAllFrames);
	register_method((char*)"InvertColorsAllFramesName", &NodeChromaSDK::InvertColorsAllFramesName);
	register_method((char*)"InvertColorsAllFramesNameD", &NodeChromaSDK::InvertColorsAllFramesNameD);
	register_method((char*)"InvertColorsName", &NodeChromaSDK::InvertColorsName);
	register_method((char*)"InvertColorsNameD", &NodeChromaSDK::InvertColorsNameD);
	register_method((char*)"IsAnimationPaused", &NodeChromaSDK::IsAnimationPaused);
	register_method((char*)"IsAnimationPausedName", &NodeChromaSDK::IsAnimationPausedName);
	register_method((char*)"IsAnimationPausedNameD", &NodeChromaSDK::IsAnimationPausedNameD);
	register_method((char*)"IsDialogOpen", &NodeChromaSDK::IsDialogOpen);
	register_method((char*)"IsDialogOpenD", &NodeChromaSDK::IsDialogOpenD);
	register_method((char*)"IsInitialized", &NodeChromaSDK::IsInitialized);
	register_method((char*)"IsInitializedD", &NodeChromaSDK::IsInitializedD);
	register_method((char*)"IsPlatformSupported", &NodeChromaSDK::IsPlatformSupported);
	register_method((char*)"IsPlatformSupportedD", &NodeChromaSDK::IsPlatformSupportedD);
	register_method((char*)"IsPlaying", &NodeChromaSDK::IsPlaying);
	register_method((char*)"IsPlayingD", &NodeChromaSDK::IsPlayingD);
	register_method((char*)"IsPlayingName", &NodeChromaSDK::IsPlayingName);
	register_method((char*)"IsPlayingNameD", &NodeChromaSDK::IsPlayingNameD);
	register_method((char*)"IsPlayingType", &NodeChromaSDK::IsPlayingType);
	register_method((char*)"IsPlayingTypeD", &NodeChromaSDK::IsPlayingTypeD);
	register_method((char*)"Lerp", &NodeChromaSDK::Lerp);
	register_method((char*)"LerpColor", &NodeChromaSDK::LerpColor);
	register_method((char*)"LoadAnimation", &NodeChromaSDK::LoadAnimation);
	register_method((char*)"LoadAnimationD", &NodeChromaSDK::LoadAnimationD);
	register_method((char*)"LoadAnimationName", &NodeChromaSDK::LoadAnimationName);
	register_method((char*)"LoadComposite", &NodeChromaSDK::LoadComposite);
	register_method((char*)"MakeBlankFrames", &NodeChromaSDK::MakeBlankFrames);
	register_method((char*)"MakeBlankFramesName", &NodeChromaSDK::MakeBlankFramesName);
	register_method((char*)"MakeBlankFramesNameD", &NodeChromaSDK::MakeBlankFramesNameD);
	register_method((char*)"MakeBlankFramesRandom", &NodeChromaSDK::MakeBlankFramesRandom);
	register_method((char*)"MakeBlankFramesRandomBlackAndWhite", &NodeChromaSDK::MakeBlankFramesRandomBlackAndWhite);
	register_method((char*)"MakeBlankFramesRandomBlackAndWhiteName", &NodeChromaSDK::MakeBlankFramesRandomBlackAndWhiteName);
	register_method((char*)"MakeBlankFramesRandomBlackAndWhiteNameD", &NodeChromaSDK::MakeBlankFramesRandomBlackAndWhiteNameD);
	register_method((char*)"MakeBlankFramesRandomName", &NodeChromaSDK::MakeBlankFramesRandomName);
	register_method((char*)"MakeBlankFramesRandomNameD", &NodeChromaSDK::MakeBlankFramesRandomNameD);
	register_method((char*)"MakeBlankFramesRGB", &NodeChromaSDK::MakeBlankFramesRGB);
	register_method((char*)"MakeBlankFramesRGBName", &NodeChromaSDK::MakeBlankFramesRGBName);
	register_method((char*)"MakeBlankFramesRGBNameD", &NodeChromaSDK::MakeBlankFramesRGBNameD);
	register_method((char*)"MirrorHorizontally", &NodeChromaSDK::MirrorHorizontally);
	register_method((char*)"MirrorVertically", &NodeChromaSDK::MirrorVertically);
	register_method((char*)"MultiplyColorLerpAllFrames", &NodeChromaSDK::MultiplyColorLerpAllFrames);
	register_method((char*)"MultiplyColorLerpAllFramesName", &NodeChromaSDK::MultiplyColorLerpAllFramesName);
	register_method((char*)"MultiplyColorLerpAllFramesNameD", &NodeChromaSDK::MultiplyColorLerpAllFramesNameD);
	register_method((char*)"MultiplyIntensity", &NodeChromaSDK::MultiplyIntensity);
	register_method((char*)"MultiplyIntensityAllFrames", &NodeChromaSDK::MultiplyIntensityAllFrames);
	register_method((char*)"MultiplyIntensityAllFramesName", &NodeChromaSDK::MultiplyIntensityAllFramesName);
	register_method((char*)"MultiplyIntensityAllFramesNameD", &NodeChromaSDK::MultiplyIntensityAllFramesNameD);
	register_method((char*)"MultiplyIntensityAllFramesRGB", &NodeChromaSDK::MultiplyIntensityAllFramesRGB);
	register_method((char*)"MultiplyIntensityAllFramesRGBName", &NodeChromaSDK::MultiplyIntensityAllFramesRGBName);
	register_method((char*)"MultiplyIntensityAllFramesRGBNameD", &NodeChromaSDK::MultiplyIntensityAllFramesRGBNameD);
	register_method((char*)"MultiplyIntensityColor", &NodeChromaSDK::MultiplyIntensityColor);
	register_method((char*)"MultiplyIntensityColorAllFrames", &NodeChromaSDK::MultiplyIntensityColorAllFrames);
	register_method((char*)"MultiplyIntensityColorAllFramesName", &NodeChromaSDK::MultiplyIntensityColorAllFramesName);
	register_method((char*)"MultiplyIntensityColorAllFramesNameD", &NodeChromaSDK::MultiplyIntensityColorAllFramesNameD);
	register_method((char*)"MultiplyIntensityColorName", &NodeChromaSDK::MultiplyIntensityColorName);
	register_method((char*)"MultiplyIntensityColorNameD", &NodeChromaSDK::MultiplyIntensityColorNameD);
	register_method((char*)"MultiplyIntensityName", &NodeChromaSDK::MultiplyIntensityName);
	register_method((char*)"MultiplyIntensityNameD", &NodeChromaSDK::MultiplyIntensityNameD);
	register_method((char*)"MultiplyIntensityRGB", &NodeChromaSDK::MultiplyIntensityRGB);
	register_method((char*)"MultiplyIntensityRGBName", &NodeChromaSDK::MultiplyIntensityRGBName);
	register_method((char*)"MultiplyIntensityRGBNameD", &NodeChromaSDK::MultiplyIntensityRGBNameD);
	register_method((char*)"MultiplyNonZeroTargetColorLerp", &NodeChromaSDK::MultiplyNonZeroTargetColorLerp);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFrames", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFrames);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFramesName", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesName);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFramesNameD", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesNameD);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFramesRGB", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGB);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFramesRGBName", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGBName);
	register_method((char*)"MultiplyNonZeroTargetColorLerpAllFramesRGBNameD", &NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGBNameD);
	register_method((char*)"MultiplyTargetColorLerp", &NodeChromaSDK::MultiplyTargetColorLerp);
	register_method((char*)"MultiplyTargetColorLerpAllFrames", &NodeChromaSDK::MultiplyTargetColorLerpAllFrames);
	register_method((char*)"MultiplyTargetColorLerpAllFramesName", &NodeChromaSDK::MultiplyTargetColorLerpAllFramesName);
	register_method((char*)"MultiplyTargetColorLerpAllFramesNameD", &NodeChromaSDK::MultiplyTargetColorLerpAllFramesNameD);
	register_method((char*)"MultiplyTargetColorLerpAllFramesRGB", &NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGB);
	register_method((char*)"MultiplyTargetColorLerpAllFramesRGBName", &NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGBName);
	register_method((char*)"MultiplyTargetColorLerpAllFramesRGBNameD", &NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGBNameD);
	register_method((char*)"OffsetColors", &NodeChromaSDK::OffsetColors);
	register_method((char*)"OffsetColorsAllFrames", &NodeChromaSDK::OffsetColorsAllFrames);
	register_method((char*)"OffsetColorsAllFramesName", &NodeChromaSDK::OffsetColorsAllFramesName);
	register_method((char*)"OffsetColorsAllFramesNameD", &NodeChromaSDK::OffsetColorsAllFramesNameD);
	register_method((char*)"OffsetColorsName", &NodeChromaSDK::OffsetColorsName);
	register_method((char*)"OffsetColorsNameD", &NodeChromaSDK::OffsetColorsNameD);
	register_method((char*)"OffsetNonZeroColors", &NodeChromaSDK::OffsetNonZeroColors);
	register_method((char*)"OffsetNonZeroColorsAllFrames", &NodeChromaSDK::OffsetNonZeroColorsAllFrames);
	register_method((char*)"OffsetNonZeroColorsAllFramesName", &NodeChromaSDK::OffsetNonZeroColorsAllFramesName);
	register_method((char*)"OffsetNonZeroColorsAllFramesNameD", &NodeChromaSDK::OffsetNonZeroColorsAllFramesNameD);
	register_method((char*)"OffsetNonZeroColorsName", &NodeChromaSDK::OffsetNonZeroColorsName);
	register_method((char*)"OffsetNonZeroColorsNameD", &NodeChromaSDK::OffsetNonZeroColorsNameD);
	register_method((char*)"OpenAnimation", &NodeChromaSDK::OpenAnimation);
	register_method((char*)"OpenAnimationD", &NodeChromaSDK::OpenAnimationD);
	//register_method((char*)"OpenAnimationFromMemory", &NodeChromaSDK::OpenAnimationFromMemory);
	register_method((char*)"OpenEditorDialog", &NodeChromaSDK::OpenEditorDialog);
	register_method((char*)"OpenEditorDialogAndPlay", &NodeChromaSDK::OpenEditorDialogAndPlay);
	register_method((char*)"OpenEditorDialogAndPlayD", &NodeChromaSDK::OpenEditorDialogAndPlayD);
	register_method((char*)"OpenEditorDialogD", &NodeChromaSDK::OpenEditorDialogD);
	register_method((char*)"OverrideFrameDuration", &NodeChromaSDK::OverrideFrameDuration);
	register_method((char*)"OverrideFrameDurationD", &NodeChromaSDK::OverrideFrameDurationD);
	register_method((char*)"OverrideFrameDurationName", &NodeChromaSDK::OverrideFrameDurationName);
	register_method((char*)"PauseAnimation", &NodeChromaSDK::PauseAnimation);
	register_method((char*)"PauseAnimationName", &NodeChromaSDK::PauseAnimationName);
	register_method((char*)"PauseAnimationNameD", &NodeChromaSDK::PauseAnimationNameD);
	register_method((char*)"PlayAnimation", &NodeChromaSDK::PlayAnimation);
	register_method((char*)"PlayAnimationD", &NodeChromaSDK::PlayAnimationD);
	register_method((char*)"PlayAnimationFrame", &NodeChromaSDK::PlayAnimationFrame);
	register_method((char*)"PlayAnimationFrameName", &NodeChromaSDK::PlayAnimationFrameName);
	register_method((char*)"PlayAnimationFrameNameD", &NodeChromaSDK::PlayAnimationFrameNameD);
	register_method((char*)"PlayAnimationLoop", &NodeChromaSDK::PlayAnimationLoop);
	register_method((char*)"PlayAnimationName", &NodeChromaSDK::PlayAnimationName);
	register_method((char*)"PlayAnimationNameD", &NodeChromaSDK::PlayAnimationNameD);
	register_method((char*)"PlayComposite", &NodeChromaSDK::PlayComposite);
	register_method((char*)"PlayCompositeD", &NodeChromaSDK::PlayCompositeD);
	register_method((char*)"PreviewFrame", &NodeChromaSDK::PreviewFrame);
	register_method((char*)"PreviewFrameD", &NodeChromaSDK::PreviewFrameD);
	register_method((char*)"PreviewFrameName", &NodeChromaSDK::PreviewFrameName);
	register_method((char*)"ReduceFrames", &NodeChromaSDK::ReduceFrames);
	register_method((char*)"ReduceFramesName", &NodeChromaSDK::ReduceFramesName);
	register_method((char*)"ReduceFramesNameD", &NodeChromaSDK::ReduceFramesNameD);
	register_method((char*)"ResetAnimation", &NodeChromaSDK::ResetAnimation);
	register_method((char*)"ResumeAnimation", &NodeChromaSDK::ResumeAnimation);
	register_method((char*)"ResumeAnimationName", &NodeChromaSDK::ResumeAnimationName);
	register_method((char*)"ResumeAnimationNameD", &NodeChromaSDK::ResumeAnimationNameD);
	register_method((char*)"Reverse", &NodeChromaSDK::Reverse);
	register_method((char*)"ReverseAllFrames", &NodeChromaSDK::ReverseAllFrames);
	register_method((char*)"ReverseAllFramesName", &NodeChromaSDK::ReverseAllFramesName);
	register_method((char*)"ReverseAllFramesNameD", &NodeChromaSDK::ReverseAllFramesNameD);
	register_method((char*)"SaveAnimation", &NodeChromaSDK::SaveAnimation);
	register_method((char*)"SaveAnimationName", &NodeChromaSDK::SaveAnimationName);
	register_method((char*)"Set1DColor", &NodeChromaSDK::Set1DColor);
	register_method((char*)"Set1DColorName", &NodeChromaSDK::Set1DColorName);
	register_method((char*)"Set1DColorNameD", &NodeChromaSDK::Set1DColorNameD);
	register_method((char*)"Set2DColor", &NodeChromaSDK::Set2DColor);
	register_method((char*)"Set2DColorName", &NodeChromaSDK::Set2DColorName);
	register_method((char*)"Set2DColorNameD", &NodeChromaSDK::Set2DColorNameD);
	register_method((char*)"SetChromaCustomColorAllFrames", &NodeChromaSDK::SetChromaCustomColorAllFrames);
	register_method((char*)"SetChromaCustomColorAllFramesName", &NodeChromaSDK::SetChromaCustomColorAllFramesName);
	register_method((char*)"SetChromaCustomColorAllFramesNameD", &NodeChromaSDK::SetChromaCustomColorAllFramesNameD);
	register_method((char*)"SetChromaCustomFlag", &NodeChromaSDK::SetChromaCustomFlag);
	register_method((char*)"SetChromaCustomFlagName", &NodeChromaSDK::SetChromaCustomFlagName);
	register_method((char*)"SetChromaCustomFlagNameD", &NodeChromaSDK::SetChromaCustomFlagNameD);
	register_method((char*)"SetCurrentFrame", &NodeChromaSDK::SetCurrentFrame);
	register_method((char*)"SetCurrentFrameName", &NodeChromaSDK::SetCurrentFrameName);
	register_method((char*)"SetCurrentFrameNameD", &NodeChromaSDK::SetCurrentFrameNameD);
	register_method((char*)"SetDevice", &NodeChromaSDK::SetDevice);
	//register_method((char*)"SetEffect", &NodeChromaSDK::SetEffect);
	register_method((char*)"SetIdleAnimation", &NodeChromaSDK::SetIdleAnimation);
	register_method((char*)"SetIdleAnimationName", &NodeChromaSDK::SetIdleAnimationName);
	register_method((char*)"SetKeyColor", &NodeChromaSDK::SetKeyColor);
	register_method((char*)"SetKeyColorAllFrames", &NodeChromaSDK::SetKeyColorAllFrames);
	register_method((char*)"SetKeyColorAllFramesName", &NodeChromaSDK::SetKeyColorAllFramesName);
	register_method((char*)"SetKeyColorAllFramesNameD", &NodeChromaSDK::SetKeyColorAllFramesNameD);
	register_method((char*)"SetKeyColorAllFramesRGB", &NodeChromaSDK::SetKeyColorAllFramesRGB);
	register_method((char*)"SetKeyColorAllFramesRGBName", &NodeChromaSDK::SetKeyColorAllFramesRGBName);
	register_method((char*)"SetKeyColorAllFramesRGBNameD", &NodeChromaSDK::SetKeyColorAllFramesRGBNameD);
	register_method((char*)"SetKeyColorName", &NodeChromaSDK::SetKeyColorName);
	register_method((char*)"SetKeyColorNameD", &NodeChromaSDK::SetKeyColorNameD);
	register_method((char*)"SetKeyColorRGB", &NodeChromaSDK::SetKeyColorRGB);
	register_method((char*)"SetKeyColorRGBName", &NodeChromaSDK::SetKeyColorRGBName);
	register_method((char*)"SetKeyColorRGBNameD", &NodeChromaSDK::SetKeyColorRGBNameD);
	register_method((char*)"SetKeyNonZeroColor", &NodeChromaSDK::SetKeyNonZeroColor);
	register_method((char*)"SetKeyNonZeroColorName", &NodeChromaSDK::SetKeyNonZeroColorName);
	register_method((char*)"SetKeyNonZeroColorNameD", &NodeChromaSDK::SetKeyNonZeroColorNameD);
	register_method((char*)"SetKeyNonZeroColorRGB", &NodeChromaSDK::SetKeyNonZeroColorRGB);
	register_method((char*)"SetKeyNonZeroColorRGBName", &NodeChromaSDK::SetKeyNonZeroColorRGBName);
	register_method((char*)"SetKeyNonZeroColorRGBNameD", &NodeChromaSDK::SetKeyNonZeroColorRGBNameD);
	register_method((char*)"SetKeysColor", &NodeChromaSDK::SetKeysColor);
	register_method((char*)"SetKeysColorAllFrames", &NodeChromaSDK::SetKeysColorAllFrames);
	register_method((char*)"SetKeysColorAllFramesName", &NodeChromaSDK::SetKeysColorAllFramesName);
	register_method((char*)"SetKeysColorAllFramesRGB", &NodeChromaSDK::SetKeysColorAllFramesRGB);
	register_method((char*)"SetKeysColorAllFramesRGBName", &NodeChromaSDK::SetKeysColorAllFramesRGBName);
	register_method((char*)"SetKeysColorName", &NodeChromaSDK::SetKeysColorName);
	register_method((char*)"SetKeysColorRGB", &NodeChromaSDK::SetKeysColorRGB);
	register_method((char*)"SetKeysColorRGBName", &NodeChromaSDK::SetKeysColorRGBName);
	register_method((char*)"SetKeysNonZeroColor", &NodeChromaSDK::SetKeysNonZeroColor);
	register_method((char*)"SetKeysNonZeroColorAllFrames", &NodeChromaSDK::SetKeysNonZeroColorAllFrames);
	register_method((char*)"SetKeysNonZeroColorAllFramesName", &NodeChromaSDK::SetKeysNonZeroColorAllFramesName);
	register_method((char*)"SetKeysNonZeroColorName", &NodeChromaSDK::SetKeysNonZeroColorName);
	register_method((char*)"SetKeysNonZeroColorRGB", &NodeChromaSDK::SetKeysNonZeroColorRGB);
	register_method((char*)"SetKeysNonZeroColorRGBName", &NodeChromaSDK::SetKeysNonZeroColorRGBName);
	register_method((char*)"SetKeysZeroColor", &NodeChromaSDK::SetKeysZeroColor);
	register_method((char*)"SetKeysZeroColorAllFrames", &NodeChromaSDK::SetKeysZeroColorAllFrames);
	register_method((char*)"SetKeysZeroColorAllFramesName", &NodeChromaSDK::SetKeysZeroColorAllFramesName);
	register_method((char*)"SetKeysZeroColorAllFramesRGB", &NodeChromaSDK::SetKeysZeroColorAllFramesRGB);
	register_method((char*)"SetKeysZeroColorAllFramesRGBName", &NodeChromaSDK::SetKeysZeroColorAllFramesRGBName);
	register_method((char*)"SetKeysZeroColorName", &NodeChromaSDK::SetKeysZeroColorName);
	register_method((char*)"SetKeysZeroColorRGB", &NodeChromaSDK::SetKeysZeroColorRGB);
	register_method((char*)"SetKeysZeroColorRGBName", &NodeChromaSDK::SetKeysZeroColorRGBName);
	register_method((char*)"SetKeyZeroColor", &NodeChromaSDK::SetKeyZeroColor);
	register_method((char*)"SetKeyZeroColorName", &NodeChromaSDK::SetKeyZeroColorName);
	register_method((char*)"SetKeyZeroColorNameD", &NodeChromaSDK::SetKeyZeroColorNameD);
	register_method((char*)"SetKeyZeroColorRGB", &NodeChromaSDK::SetKeyZeroColorRGB);
	register_method((char*)"SetKeyZeroColorRGBName", &NodeChromaSDK::SetKeyZeroColorRGBName);
	register_method((char*)"SetKeyZeroColorRGBNameD", &NodeChromaSDK::SetKeyZeroColorRGBNameD);
	//register_method((char*)"SetLogDelegate", &NodeChromaSDK::SetLogDelegate);
	register_method((char*)"StaticColor", &NodeChromaSDK::StaticColor);
	register_method((char*)"StaticColorD", &NodeChromaSDK::StaticColorD);
	register_method((char*)"StopAll", &NodeChromaSDK::StopAll);
	register_method((char*)"StopAnimation", &NodeChromaSDK::StopAnimation);
	register_method((char*)"StopAnimationD", &NodeChromaSDK::StopAnimationD);
	register_method((char*)"StopAnimationName", &NodeChromaSDK::StopAnimationName);
	register_method((char*)"StopAnimationNameD", &NodeChromaSDK::StopAnimationNameD);
	register_method((char*)"StopAnimationType", &NodeChromaSDK::StopAnimationType);
	register_method((char*)"StopAnimationTypeD", &NodeChromaSDK::StopAnimationTypeD);
	register_method((char*)"StopComposite", &NodeChromaSDK::StopComposite);
	register_method((char*)"StopCompositeD", &NodeChromaSDK::StopCompositeD);
	register_method((char*)"SubtractNonZeroAllKeysAllFrames", &NodeChromaSDK::SubtractNonZeroAllKeysAllFrames);
	register_method((char*)"SubtractNonZeroAllKeysAllFramesName", &NodeChromaSDK::SubtractNonZeroAllKeysAllFramesName);
	register_method((char*)"SubtractNonZeroAllKeysAllFramesNameD", &NodeChromaSDK::SubtractNonZeroAllKeysAllFramesNameD);
	register_method((char*)"SubtractNonZeroAllKeysAllFramesOffset", &NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffset);
	register_method((char*)"SubtractNonZeroAllKeysAllFramesOffsetName", &NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffsetName);
	register_method((char*)"SubtractNonZeroAllKeysAllFramesOffsetNameD", &NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffsetNameD);
	register_method((char*)"SubtractNonZeroAllKeysOffset", &NodeChromaSDK::SubtractNonZeroAllKeysOffset);
	register_method((char*)"SubtractNonZeroAllKeysOffsetName", &NodeChromaSDK::SubtractNonZeroAllKeysOffsetName);
	register_method((char*)"SubtractNonZeroAllKeysOffsetNameD", &NodeChromaSDK::SubtractNonZeroAllKeysOffsetNameD);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFrames", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFrames);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFramesName", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesName);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFramesNameD", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesNameD);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFramesOffset", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffset);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFramesOffsetName", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffsetName);
	register_method((char*)"SubtractNonZeroTargetAllKeysAllFramesOffsetNameD", &NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffsetNameD);
	register_method((char*)"SubtractNonZeroTargetAllKeysOffset", &NodeChromaSDK::SubtractNonZeroTargetAllKeysOffset);
	register_method((char*)"SubtractNonZeroTargetAllKeysOffsetName", &NodeChromaSDK::SubtractNonZeroTargetAllKeysOffsetName);
	register_method((char*)"SubtractNonZeroTargetAllKeysOffsetNameD", &NodeChromaSDK::SubtractNonZeroTargetAllKeysOffsetNameD);
	register_method((char*)"TrimEndFrames", &NodeChromaSDK::TrimEndFrames);
	register_method((char*)"TrimEndFramesName", &NodeChromaSDK::TrimEndFramesName);
	register_method((char*)"TrimEndFramesNameD", &NodeChromaSDK::TrimEndFramesNameD);
	register_method((char*)"TrimFrame", &NodeChromaSDK::TrimFrame);
	register_method((char*)"TrimFrameName", &NodeChromaSDK::TrimFrameName);
	register_method((char*)"TrimFrameNameD", &NodeChromaSDK::TrimFrameNameD);
	register_method((char*)"TrimStartFrames", &NodeChromaSDK::TrimStartFrames);
	register_method((char*)"TrimStartFramesName", &NodeChromaSDK::TrimStartFramesName);
	register_method((char*)"TrimStartFramesNameD", &NodeChromaSDK::TrimStartFramesNameD);
	register_method((char*)"Uninit", &NodeChromaSDK::Uninit);
	register_method((char*)"UninitD", &NodeChromaSDK::UninitD);
	register_method((char*)"UnloadAnimation", &NodeChromaSDK::UnloadAnimation);
	register_method((char*)"UnloadAnimationD", &NodeChromaSDK::UnloadAnimationD);
	register_method((char*)"UnloadAnimationName", &NodeChromaSDK::UnloadAnimationName);
	register_method((char*)"UnloadComposite", &NodeChromaSDK::UnloadComposite);
	//register_method((char*)"UpdateFrame", &NodeChromaSDK::UpdateFrame);
	register_method((char*)"UseIdleAnimation", &NodeChromaSDK::UseIdleAnimation);
	register_method((char*)"UseIdleAnimations", &NodeChromaSDK::UseIdleAnimations);
	register_method((char*)"UsePreloading", &NodeChromaSDK::UsePreloading);
	register_method((char*)"UsePreloadingName", &NodeChromaSDK::UsePreloadingName);
#pragma endregion
}

void NodeChromaSDK::_init() {
}

NodeChromaSDK::NodeChromaSDK() {
	if (ChromaAnimationAPI::InitAPI() == 0)
	{
		fprintf(stderr, "Loaded Chroma SDK Plugin!\r\n");
	}
	else
	{
		fprintf(stderr, "Failed to loaded Chroma SDK Plugin!\r\n");
	}
}

NodeChromaSDK::~NodeChromaSDK()
{
	if (ChromaAnimationAPI::GetIsInitializedAPI())
	{
		if (ChromaAnimationAPI::IsInitialized())
		{
			ChromaAnimationAPI::StopAll();
			ChromaAnimationAPI::CloseAll();
			ChromaAnimationAPI::Uninit();
		}
	}
}

bool godot::NodeChromaSDK::IsAPIInitialized()
{
	if (ChromaAnimationAPI::GetIsInitializedAPI())
	{
		fprintf(stdout, "Chroma SDK Plugin is initialized!\r\n");
		return true;
	}
	else
	{
		fprintf(stderr, "Chroma SDK Plugin is not initialized!\r\n");
		return false;
	}
}

#pragma region autogenerated
/*
	Adds a frame to the `Chroma` animation and sets the `duration` (in seconds).
	The `color` is expected to be an array of the dimensions for the `deviceType/device`.
	The `length` parameter is the size of the `color` array. For `EChromaSDKDevice1DEnum`
	the array size should be `MAX LEDS`. For `EChromaSDKDevice2DEnum` the array
	size should be `MAX ROW` * `MAX COLUMN`. Returns the animation id upon
	success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::AddFrame(int animationId, float duration, int* colors, int length)
{
	return ChromaAnimationAPI::AddFrame(animationId, duration, colors, length);
}

/*
	Add source color to target where color is not black for all frames, reference
	source and target by id.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::AddNonZeroAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Add source color to target where color is not black for all frames, reference
	source and target by name.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::AddNonZeroAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Add source color to target where color is not black for all frames starting
	at offset for the length of the source, reference source and target by
	id.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Add source color to target where color is not black for all frames starting
	at offset for the length of the source, reference source and target by
	name.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::AddNonZeroAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::AddNonZeroAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Add source color to target where color is not black for the source frame
	and target offset frame, reference source and target by id.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::AddNonZeroAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Add source color to target where color is not black for the source frame
	and target offset frame, reference source and target by name.
*/
void godot::NodeChromaSDK::AddNonZeroAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::AddNonZeroAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::AddNonZeroAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Add source color to target where the target color is not black for all frames,
	reference source and target by id.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Add source color to target where the target color is not black for all frames,
	reference source and target by name.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Add source color to target where the target color is not black for all frames
	starting at offset for the length of the source, reference source and target
	by id.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Add source color to target where the target color is not black for all frames
	starting at offset for the length of the source, reference source and target
	by name.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroTargetAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::AddNonZeroTargetAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Add source color to target where target color is not blank from the source
	frame to the target offset frame, reference source and target by id.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Add source color to target where target color is not blank from the source
	frame to the target offset frame, reference source and target by name.
*/
void godot::NodeChromaSDK::AddNonZeroTargetAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::AddNonZeroTargetAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AddNonZeroTargetAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::AddNonZeroTargetAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Append all source frames to the target animation, reference source and target
	by id.
*/
void godot::NodeChromaSDK::AppendAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::AppendAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Append all source frames to the target animation, reference source and target
	by name.
*/
void godot::NodeChromaSDK::AppendAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::AppendAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::AppendAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::AppendAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	`PluginClearAll` will issue a `CLEAR` effect for all devices.
*/
void godot::NodeChromaSDK::ClearAll()
{
	ChromaAnimationAPI::ClearAll();
}

/*
	`PluginClearAnimationType` will issue a `CLEAR` effect for the given device.
*/
void godot::NodeChromaSDK::ClearAnimationType(int deviceType, int device)
{
	ChromaAnimationAPI::ClearAnimationType(deviceType, device);
}

/*
	`PluginCloseAll` closes all open animations so they can be reloaded from
	disk. The set of animations will be stopped if playing.
*/
void godot::NodeChromaSDK::CloseAll()
{
	ChromaAnimationAPI::CloseAll();
}

/*
	Closes the `Chroma` animation to free up resources referenced by id. Returns
	the animation id upon success. Returns -1 upon failure. This might be used
	while authoring effects if there was a change necessitating re-opening
	the animation. The animation id can no longer be used once closed.
*/
int godot::NodeChromaSDK::CloseAnimation(int animationId)
{
	return ChromaAnimationAPI::CloseAnimation(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CloseAnimationD(double animationId)
{
	return ChromaAnimationAPI::CloseAnimationD(animationId);
}

/*
	Closes the `Chroma` animation referenced by name so that the animation can
	be reloaded from disk.
*/
void godot::NodeChromaSDK::CloseAnimationName(String path)
{
	ChromaAnimationAPI::CloseAnimationName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CloseAnimationNameD(String path)
{
	return ChromaAnimationAPI::CloseAnimationNameD(path.utf8().get_data());
}

/*
	`PluginCloseComposite` closes a set of animations so they can be reloaded
	from disk. The set of animations will be stopped if playing.
*/
void godot::NodeChromaSDK::CloseComposite(String name)
{
	ChromaAnimationAPI::CloseComposite(name.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CloseCompositeD(String name)
{
	return ChromaAnimationAPI::CloseCompositeD(name.utf8().get_data());
}

/*
	Copy animation to named target animation in memory. If target animation
	exists, close first. Source is referenced by id.
*/
int godot::NodeChromaSDK::CopyAnimation(int sourceAnimationId, String targetAnimation)
{
	return ChromaAnimationAPI::CopyAnimation(sourceAnimationId, targetAnimation.utf8().get_data());
}

/*
	Copy animation to named target animation in memory. If target animation
	exists, close first. Source is referenced by name.
*/
void godot::NodeChromaSDK::CopyAnimationName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyAnimationName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyAnimationNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyAnimationNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Copy blue channel to other channels for all frames. Intensity range is 0.0
	to 1.0. Reference the animation by id.
*/
void godot::NodeChromaSDK::CopyBlueChannelAllFrames(int animationId, float redIntensity, float greenIntensity)
{
	ChromaAnimationAPI::CopyBlueChannelAllFrames(animationId, redIntensity, greenIntensity);
}

/*
	Copy blue channel to other channels for all frames. Intensity range is 0.0
	to 1.0. Reference the animation by name.
*/
void godot::NodeChromaSDK::CopyBlueChannelAllFramesName(String path, float redIntensity, float greenIntensity)
{
	ChromaAnimationAPI::CopyBlueChannelAllFramesName(path.utf8().get_data(), redIntensity, greenIntensity);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyBlueChannelAllFramesNameD(String path, double redIntensity, double greenIntensity)
{
	return ChromaAnimationAPI::CopyBlueChannelAllFramesNameD(path.utf8().get_data(), redIntensity, greenIntensity);
}

/*
	Copy green channel to other channels for all frames. Intensity range is
	0.0 to 1.0. Reference the animation by id.
*/
void godot::NodeChromaSDK::CopyGreenChannelAllFrames(int animationId, float redIntensity, float blueIntensity)
{
	ChromaAnimationAPI::CopyGreenChannelAllFrames(animationId, redIntensity, blueIntensity);
}

/*
	Copy green channel to other channels for all frames. Intensity range is
	0.0 to 1.0. Reference the animation by name.
*/
void godot::NodeChromaSDK::CopyGreenChannelAllFramesName(String path, float redIntensity, float blueIntensity)
{
	ChromaAnimationAPI::CopyGreenChannelAllFramesName(path.utf8().get_data(), redIntensity, blueIntensity);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyGreenChannelAllFramesNameD(String path, double redIntensity, double blueIntensity)
{
	return ChromaAnimationAPI::CopyGreenChannelAllFramesNameD(path.utf8().get_data(), redIntensity, blueIntensity);
}

/*
	Copy animation key color from the source animation to the target animation
	for the given frame. Reference the source and target by id.
*/
void godot::NodeChromaSDK::CopyKeyColor(int sourceAnimationId, int targetAnimationId, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyKeyColor(sourceAnimationId, targetAnimationId, frameId, rzkey);
}

/*
	Copy animation key color from the source animation to the target animation
	for all frames. Reference the source and target by id.
*/
void godot::NodeChromaSDK::CopyKeyColorAllFrames(int sourceAnimationId, int targetAnimationId, int rzkey)
{
	ChromaAnimationAPI::CopyKeyColorAllFrames(sourceAnimationId, targetAnimationId, rzkey);
}

/*
	Copy animation key color from the source animation to the target animation
	for all frames. Reference the source and target by name.
*/
void godot::NodeChromaSDK::CopyKeyColorAllFramesName(String sourceAnimation, String targetAnimation, int rzkey)
{
	ChromaAnimationAPI::CopyKeyColorAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), rzkey);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyKeyColorAllFramesNameD(String sourceAnimation, String targetAnimation, double rzkey)
{
	return ChromaAnimationAPI::CopyKeyColorAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), rzkey);
}

/*
	Copy animation key color from the source animation to the target animation
	for all frames, starting at the offset for the length of the source animation.
	Source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyKeyColorAllFramesOffset(int sourceAnimationId, int targetAnimationId, int rzkey, int offset)
{
	ChromaAnimationAPI::CopyKeyColorAllFramesOffset(sourceAnimationId, targetAnimationId, rzkey, offset);
}

/*
	Copy animation key color from the source animation to the target animation
	for all frames, starting at the offset for the length of the source animation.
	Source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyKeyColorAllFramesOffsetName(String sourceAnimation, String targetAnimation, int rzkey, int offset)
{
	ChromaAnimationAPI::CopyKeyColorAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), rzkey, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyKeyColorAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double rzkey, double offset)
{
	return ChromaAnimationAPI::CopyKeyColorAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), rzkey, offset);
}

/*
	Copy animation key color from the source animation to the target animation
	for the given frame.
*/
void godot::NodeChromaSDK::CopyKeyColorName(String sourceAnimation, String targetAnimation, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyKeyColorName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyKeyColorNameD(String sourceAnimation, String targetAnimation, double frameId, double rzkey)
{
	return ChromaAnimationAPI::CopyKeyColorNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation for the given frame. Reference the source and target by
	id.
*/
void godot::NodeChromaSDK::CopyKeysColor(int sourceAnimationId, int targetAnimationId, int frameId, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColor(sourceAnimationId, targetAnimationId, frameId, ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation for all frames. Reference the source and target by id.
*/
void godot::NodeChromaSDK::CopyKeysColorAllFrames(int sourceAnimationId, int targetAnimationId, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColorAllFrames(sourceAnimationId, targetAnimationId, ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation for all frames. Reference the source and target by name.
*/
void godot::NodeChromaSDK::CopyKeysColorAllFramesName(String sourceAnimation, String targetAnimation, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColorAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation for the given frame. Reference the source and target by
	name.
*/
void godot::NodeChromaSDK::CopyKeysColorName(String sourceAnimation, String targetAnimation, int frameId, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColorName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation from the source frame to the target frame. Reference the
	source and target by id.
*/
void godot::NodeChromaSDK::CopyKeysColorOffset(int sourceAnimationId, int targetAnimationId, int sourceFrameId, int targetFrameId, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColorOffset(sourceAnimationId, targetAnimationId, sourceFrameId, targetFrameId, ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy animation color for a set of keys from the source animation to the
	target animation from the source frame to the target frame. Reference the
	source and target by name.
*/
void godot::NodeChromaSDK::CopyKeysColorOffsetName(String sourceAnimation, String targetAnimation, int sourceFrameId, int targetFrameId, Array keys, int size)
{
	if (keys.size())
	{
		int* ptrKeys = new int[keys.size()];
		for (int i = 0; i < keys.size(); ++i)
		{
			ptrKeys[i] = (int)keys[i];
		}
		ChromaAnimationAPI::CopyKeysColorOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), sourceFrameId, targetFrameId, ptrKeys, size);
		delete[] ptrKeys;
	}
}

/*
	Copy source animation to target animation for the given frame. Source and
	target are referenced by id.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeys(int sourceAnimationId, int targetAnimationId, int frameId)
{
	ChromaAnimationAPI::CopyNonZeroAllKeys(sourceAnimationId, targetAnimationId, frameId);
}

/*
	Copy nonzero colors from a source animation to a target animation for all
	frames. Reference source and target by id.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Copy nonzero colors from a source animation to a target animation for all
	frames. Reference source and target by name.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Copy nonzero colors from a source animation to a target animation for all
	frames starting at the offset for the length of the source animation. The
	source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Copy nonzero colors from a source animation to a target animation for all
	frames starting at the offset for the length of the source animation. The
	source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::CopyNonZeroAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Copy nonzero colors from source animation to target animation for the specified
	frame. Source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysName(String sourceAnimation, String targetAnimation, int frameId)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroAllKeysNameD(String sourceAnimation, String targetAnimation, double frameId)
{
	return ChromaAnimationAPI::CopyNonZeroAllKeysNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId);
}

/*
	Copy nonzero colors from the source animation to the target animation from
	the source frame to the target offset frame. Source and target are referenced
	by id.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Copy nonzero colors from the source animation to the target animation from
	the source frame to the target offset frame. Source and target are referenced
	by name.
*/
void godot::NodeChromaSDK::CopyNonZeroAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::CopyNonZeroAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Copy animation key color from the source animation to the target animation
	for the given frame where color is not zero.
*/
void godot::NodeChromaSDK::CopyNonZeroKeyColor(int sourceAnimationId, int targetAnimationId, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyNonZeroKeyColor(sourceAnimationId, targetAnimationId, frameId, rzkey);
}

/*
	Copy animation key color from the source animation to the target animation
	for the given frame where color is not zero.
*/
void godot::NodeChromaSDK::CopyNonZeroKeyColorName(String sourceAnimation, String targetAnimation, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyNonZeroKeyColorName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroKeyColorNameD(String sourceAnimation, String targetAnimation, double frameId, double rzkey)
{
	return ChromaAnimationAPI::CopyNonZeroKeyColorNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for the specified frame. Source and target
	are referenced by id.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeys(int sourceAnimationId, int targetAnimationId, int frameId)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeys(sourceAnimationId, targetAnimationId, frameId);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for all frames. Source and target are referenced
	by id.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for all frames. Source and target are referenced
	by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for all frames. Source and target are referenced
	by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for all frames starting at the target offset
	for the length of the source animation. Source and target animations are
	referenced by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroTargetAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::CopyNonZeroTargetAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for the specified frame. The source and target
	are referenced by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysName(String sourceAnimation, String targetAnimation, int frameId)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroTargetAllKeysNameD(String sourceAnimation, String targetAnimation, double frameId)
{
	return ChromaAnimationAPI::CopyNonZeroTargetAllKeysNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for the specified source frame and target offset
	frame. The source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is nonzero for the specified source frame and target offset
	frame. The source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::CopyNonZeroTargetAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroTargetAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::CopyNonZeroTargetAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is zero for all frames. Source and target are referenced
	by id.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::CopyNonZeroTargetZeroAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Copy nonzero colors from the source animation to the target animation where
	the target color is zero for all frames. Source and target are referenced
	by name.
*/
void godot::NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyNonZeroTargetZeroAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyNonZeroTargetZeroAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyNonZeroTargetZeroAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Copy red channel to other channels for all frames. Intensity range is 0.0
	to 1.0. Reference the animation by id.
*/
void godot::NodeChromaSDK::CopyRedChannelAllFrames(int animationId, float greenIntensity, float blueIntensity)
{
	ChromaAnimationAPI::CopyRedChannelAllFrames(animationId, greenIntensity, blueIntensity);
}

/*
	Copy green channel to other channels for all frames. Intensity range is
	0.0 to 1.0. Reference the animation by name.
*/
void godot::NodeChromaSDK::CopyRedChannelAllFramesName(String path, float greenIntensity, float blueIntensity)
{
	ChromaAnimationAPI::CopyRedChannelAllFramesName(path.utf8().get_data(), greenIntensity, blueIntensity);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyRedChannelAllFramesNameD(String path, double greenIntensity, double blueIntensity)
{
	return ChromaAnimationAPI::CopyRedChannelAllFramesNameD(path.utf8().get_data(), greenIntensity, blueIntensity);
}

/*
	Copy zero colors from source animation to target animation for all frames.
	Source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyZeroAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::CopyZeroAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Copy zero colors from source animation to target animation for all frames.
	Source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyZeroAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyZeroAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyZeroAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyZeroAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Copy zero colors from source animation to target animation for all frames
	starting at the target offset for the length of the source animation. Source
	and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyZeroAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::CopyZeroAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Copy zero colors from source animation to target animation for all frames
	starting at the target offset for the length of the source animation. Source
	and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyZeroAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::CopyZeroAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyZeroAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::CopyZeroAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Copy zero key color from source animation to target animation for the specified
	frame. Source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyZeroKeyColor(int sourceAnimationId, int targetAnimationId, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyZeroKeyColor(sourceAnimationId, targetAnimationId, frameId, rzkey);
}

/*
	Copy zero key color from source animation to target animation for the specified
	frame. Source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyZeroKeyColorName(String sourceAnimation, String targetAnimation, int frameId, int rzkey)
{
	ChromaAnimationAPI::CopyZeroKeyColorName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyZeroKeyColorNameD(String sourceAnimation, String targetAnimation, double frameId, double rzkey)
{
	return ChromaAnimationAPI::CopyZeroKeyColorNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, rzkey);
}

/*
	Copy nonzero color from source animation to target animation where target
	is zero for all frames. Source and target are referenced by id.
*/
void godot::NodeChromaSDK::CopyZeroTargetAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::CopyZeroTargetAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Copy nonzero color from source animation to target animation where target
	is zero for all frames. Source and target are referenced by name.
*/
void godot::NodeChromaSDK::CopyZeroTargetAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::CopyZeroTargetAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::CopyZeroTargetAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::CopyZeroTargetAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateChromaLinkEffect(ChromaSDK::ChromaLink::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateChromaLinkEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateEffect(RZDEVICEID DeviceId, ChromaSDK::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateEffect(DeviceId, Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateHeadsetEffect(ChromaSDK::Headset::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateHeadsetEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateKeyboardEffect(ChromaSDK::Keyboard::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateKeyboardEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateKeypadEffect(ChromaSDK::Keypad::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateKeypadEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateMouseEffect(ChromaSDK::Mouse::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateMouseEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreCreateMousepadEffect(ChromaSDK::Mousepad::EFFECT_TYPE Effect, PRZPARAM pParam, RZEFFECTID* pEffectId)
{
	return ChromaAnimationAPI::CoreCreateMousepadEffect(Effect, pParam, pEffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreDeleteEffect(RZEFFECTID EffectId)
{
	return ChromaAnimationAPI::CoreDeleteEffect(EffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreInit()
{
	return ChromaAnimationAPI::CoreInit();
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreQueryDevice(RZDEVICEID DeviceId, ChromaSDK::DEVICE_INFO_TYPE& DeviceInfo)
{
	return ChromaAnimationAPI::CoreQueryDevice(DeviceId, DeviceInfo);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreSetEffect(RZEFFECTID EffectId)
{
	return ChromaAnimationAPI::CoreSetEffect(EffectId);
}

/*
	Direct access to low level API.
*/
RZRESULT godot::NodeChromaSDK::CoreUnInit()
{
	return ChromaAnimationAPI::CoreUnInit();
}

/*
	Creates a `Chroma` animation at the given path. The `deviceType` parameter
	uses `EChromaSDKDeviceTypeEnum` as an integer. The `device` parameter uses
	`EChromaSDKDevice1DEnum` or `EChromaSDKDevice2DEnum` as an integer, respective
	to the `deviceType`. Returns the animation id upon success. Returns -1
	upon failure. Saves a `Chroma` animation file with the `.chroma` extension
	at the given path. Returns the animation id upon success. Returns -1 upon
	failure.
*/
int godot::NodeChromaSDK::CreateAnimation(String path, int deviceType, int device)
{
	return ChromaAnimationAPI::CreateAnimation(path.utf8().get_data(), deviceType, device);
}

/*
	Creates a `Chroma` animation in memory without creating a file. The `deviceType`
	parameter uses `EChromaSDKDeviceTypeEnum` as an integer. The `device` parameter
	uses `EChromaSDKDevice1DEnum` or `EChromaSDKDevice2DEnum` as an integer,
	respective to the `deviceType`. Returns the animation id upon success.
	Returns -1 upon failure. Returns the animation id upon success. Returns
	-1 upon failure.
*/
int godot::NodeChromaSDK::CreateAnimationInMemory(int deviceType, int device)
{
	return ChromaAnimationAPI::CreateAnimationInMemory(deviceType, device);
}

/*
	Create a device specific effect.
*/
RZRESULT godot::NodeChromaSDK::CreateEffect(RZDEVICEID deviceId, ChromaSDK::EFFECT_TYPE effect, int* colors, int size, ChromaSDK::FChromaSDKGuid* effectId)
{
	return ChromaAnimationAPI::CreateEffect(deviceId, effect, colors, size, effectId);
}

/*
	Delete an effect given the effect id.
*/
RZRESULT godot::NodeChromaSDK::DeleteEffect(const ChromaSDK::FChromaSDKGuid& effectId)
{
	return ChromaAnimationAPI::DeleteEffect(effectId);
}

/*
	Duplicate the first animation frame so that the animation length matches
	the frame count. Animation is referenced by id.
*/
void godot::NodeChromaSDK::DuplicateFirstFrame(int animationId, int frameCount)
{
	ChromaAnimationAPI::DuplicateFirstFrame(animationId, frameCount);
}

/*
	Duplicate the first animation frame so that the animation length matches
	the frame count. Animation is referenced by name.
*/
void godot::NodeChromaSDK::DuplicateFirstFrameName(String path, int frameCount)
{
	ChromaAnimationAPI::DuplicateFirstFrameName(path.utf8().get_data(), frameCount);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::DuplicateFirstFrameNameD(String path, double frameCount)
{
	return ChromaAnimationAPI::DuplicateFirstFrameNameD(path.utf8().get_data(), frameCount);
}

/*
	Duplicate all the frames of the animation to double the animation length.
	Frame 1 becomes frame 1 and 2. Frame 2 becomes frame 3 and 4. And so on.
	The animation is referenced by id.
*/
void godot::NodeChromaSDK::DuplicateFrames(int animationId)
{
	ChromaAnimationAPI::DuplicateFrames(animationId);
}

/*
	Duplicate all the frames of the animation to double the animation length.
	Frame 1 becomes frame 1 and 2. Frame 2 becomes frame 3 and 4. And so on.
	The animation is referenced by name.
*/
void godot::NodeChromaSDK::DuplicateFramesName(String path)
{
	ChromaAnimationAPI::DuplicateFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::DuplicateFramesNameD(String path)
{
	return ChromaAnimationAPI::DuplicateFramesNameD(path.utf8().get_data());
}

/*
	Duplicate all the animation frames in reverse so that the animation plays
	forwards and backwards. Animation is referenced by id.
*/
void godot::NodeChromaSDK::DuplicateMirrorFrames(int animationId)
{
	ChromaAnimationAPI::DuplicateMirrorFrames(animationId);
}

/*
	Duplicate all the animation frames in reverse so that the animation plays
	forwards and backwards. Animation is referenced by name.
*/
void godot::NodeChromaSDK::DuplicateMirrorFramesName(String path)
{
	ChromaAnimationAPI::DuplicateMirrorFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::DuplicateMirrorFramesNameD(String path)
{
	return ChromaAnimationAPI::DuplicateMirrorFramesNameD(path.utf8().get_data());
}

/*
	Fade the animation to black starting at the fade frame index to the end
	of the animation. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FadeEndFrames(int animationId, int fade)
{
	ChromaAnimationAPI::FadeEndFrames(animationId, fade);
}

/*
	Fade the animation to black starting at the fade frame index to the end
	of the animation. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FadeEndFramesName(String path, int fade)
{
	ChromaAnimationAPI::FadeEndFramesName(path.utf8().get_data(), fade);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FadeEndFramesNameD(String path, double fade)
{
	return ChromaAnimationAPI::FadeEndFramesNameD(path.utf8().get_data(), fade);
}

/*
	Fade the animation from black to full color starting at 0 to the fade frame
	index. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FadeStartFrames(int animationId, int fade)
{
	ChromaAnimationAPI::FadeStartFrames(animationId, fade);
}

/*
	Fade the animation from black to full color starting at 0 to the fade frame
	index. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FadeStartFramesName(String path, int fade)
{
	ChromaAnimationAPI::FadeStartFramesName(path.utf8().get_data(), fade);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FadeStartFramesNameD(String path, double fade)
{
	return ChromaAnimationAPI::FadeStartFramesNameD(path.utf8().get_data(), fade);
}

/*
	Set the RGB value for all colors in the specified frame. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::FillColor(int animationId, int frameId, int color)
{
	ChromaAnimationAPI::FillColor(animationId, frameId, color);
}

/*
	Set the RGB value for all colors for all frames. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::FillColorAllFrames(int animationId, int color)
{
	ChromaAnimationAPI::FillColorAllFrames(animationId, color);
}

/*
	Set the RGB value for all colors for all frames. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::FillColorAllFramesName(String path, int color)
{
	ChromaAnimationAPI::FillColorAllFramesName(path.utf8().get_data(), color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillColorAllFramesNameD(String path, double color)
{
	return ChromaAnimationAPI::FillColorAllFramesNameD(path.utf8().get_data(), color);
}

/*
	Set the RGB value for all colors for all frames. Use the range of 0 to 255
	for red, green, and blue parameters. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillColorAllFramesRGB(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillColorAllFramesRGB(animationId, red, green, blue);
}

/*
	Set the RGB value for all colors for all frames. Use the range of 0 to 255
	for red, green, and blue parameters. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillColorAllFramesRGBName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::FillColorAllFramesRGBName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillColorAllFramesRGBNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillColorAllFramesRGBNameD(path.utf8().get_data(), red, green, blue);
}

/*
	Set the RGB value for all colors in the specified frame. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::FillColorName(String path, int frameId, int color)
{
	ChromaAnimationAPI::FillColorName(path.utf8().get_data(), frameId, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillColorNameD(String path, double frameId, double color)
{
	return ChromaAnimationAPI::FillColorNameD(path.utf8().get_data(), frameId, color);
}

/*
	Set the RGB value for all colors in the specified frame. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::FillColorRGB(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillColorRGB(animationId, frameId, red, green, blue);
}

/*
	Set the RGB value for all colors in the specified frame. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::FillColorRGBName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillColorRGBName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillColorRGBNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillColorRGBNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors in the specified
	frame. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillNonZeroColor(int animationId, int frameId, int color)
{
	ChromaAnimationAPI::FillNonZeroColor(animationId, frameId, color);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors for all frames.
	Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillNonZeroColorAllFrames(int animationId, int color)
{
	ChromaAnimationAPI::FillNonZeroColorAllFrames(animationId, color);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors for all frames.
	Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillNonZeroColorAllFramesName(String path, int color)
{
	ChromaAnimationAPI::FillNonZeroColorAllFramesName(path.utf8().get_data(), color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillNonZeroColorAllFramesNameD(String path, double color)
{
	return ChromaAnimationAPI::FillNonZeroColorAllFramesNameD(path.utf8().get_data(), color);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors for all frames.
	Use the range of 0 to 255 for red, green, and blue parameters. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::FillNonZeroColorAllFramesRGB(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillNonZeroColorAllFramesRGB(animationId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors for all frames.
	Use the range of 0 to 255 for red, green, and blue parameters. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::FillNonZeroColorAllFramesRGBName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::FillNonZeroColorAllFramesRGBName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillNonZeroColorAllFramesRGBNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillNonZeroColorAllFramesRGBNameD(path.utf8().get_data(), red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors in the specified
	frame. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillNonZeroColorName(String path, int frameId, int color)
{
	ChromaAnimationAPI::FillNonZeroColorName(path.utf8().get_data(), frameId, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillNonZeroColorNameD(String path, double frameId, double color)
{
	return ChromaAnimationAPI::FillNonZeroColorNameD(path.utf8().get_data(), frameId, color);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors in the specified
	frame. Use the range of 0 to 255 for red, green, and blue parameters. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::FillNonZeroColorRGB(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillNonZeroColorRGB(animationId, frameId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Set the RGB value for a subset of colors in the specified
	frame. Use the range of 0 to 255 for red, green, and blue parameters. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::FillNonZeroColorRGBName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillNonZeroColorRGBName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillNonZeroColorRGBNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillNonZeroColorRGBNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	Fill the frame with random RGB values for the given frame. Animation is
	referenced by id.
*/
void godot::NodeChromaSDK::FillRandomColors(int animationId, int frameId)
{
	ChromaAnimationAPI::FillRandomColors(animationId, frameId);
}

/*
	Fill the frame with random RGB values for all frames. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::FillRandomColorsAllFrames(int animationId)
{
	ChromaAnimationAPI::FillRandomColorsAllFrames(animationId);
}

/*
	Fill the frame with random RGB values for all frames. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::FillRandomColorsAllFramesName(String path)
{
	ChromaAnimationAPI::FillRandomColorsAllFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillRandomColorsAllFramesNameD(String path)
{
	return ChromaAnimationAPI::FillRandomColorsAllFramesNameD(path.utf8().get_data());
}

/*
	Fill the frame with random black and white values for the specified frame.
	Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillRandomColorsBlackAndWhite(int animationId, int frameId)
{
	ChromaAnimationAPI::FillRandomColorsBlackAndWhite(animationId, frameId);
}

/*
	Fill the frame with random black and white values for all frames. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFrames(int animationId)
{
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFrames(animationId);
}

/*
	Fill the frame with random black and white values for all frames. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFramesName(String path)
{
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillRandomColorsBlackAndWhiteAllFramesNameD(String path)
{
	return ChromaAnimationAPI::FillRandomColorsBlackAndWhiteAllFramesNameD(path.utf8().get_data());
}

/*
	Fill the frame with random black and white values for the specified frame.
	Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillRandomColorsBlackAndWhiteName(String path, int frameId)
{
	ChromaAnimationAPI::FillRandomColorsBlackAndWhiteName(path.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillRandomColorsBlackAndWhiteNameD(String path, double frameId)
{
	return ChromaAnimationAPI::FillRandomColorsBlackAndWhiteNameD(path.utf8().get_data(), frameId);
}

/*
	Fill the frame with random RGB values for the given frame. Animation is
	referenced by name.
*/
void godot::NodeChromaSDK::FillRandomColorsName(String path, int frameId)
{
	ChromaAnimationAPI::FillRandomColorsName(path.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillRandomColorsNameD(String path, double frameId)
{
	return ChromaAnimationAPI::FillRandomColorsNameD(path.utf8().get_data(), frameId);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColors(int animationId, int frameId, int threshold, int color)
{
	ChromaAnimationAPI::FillThresholdColors(animationId, frameId, threshold, color);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	RGB threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColorsAllFrames(int animationId, int threshold, int color)
{
	ChromaAnimationAPI::FillThresholdColorsAllFrames(animationId, threshold, color);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	RGB threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsAllFramesName(String path, int threshold, int color)
{
	ChromaAnimationAPI::FillThresholdColorsAllFramesName(path.utf8().get_data(), threshold, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsAllFramesNameD(String path, double threshold, double color)
{
	return ChromaAnimationAPI::FillThresholdColorsAllFramesNameD(path.utf8().get_data(), threshold, color);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColorsAllFramesRGB(int animationId, int threshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGB(animationId, threshold, red, green, blue);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsAllFramesRGBName(String path, int threshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdColorsAllFramesRGBName(path.utf8().get_data(), threshold, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsAllFramesRGBNameD(String path, double threshold, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillThresholdColorsAllFramesRGBNameD(path.utf8().get_data(), threshold, red, green, blue);
}

/*
	Fill all frames with the min RGB color where the animation color is less
	than the min threshold AND with the max RGB color where the animation is
	more than the max threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGB(int animationId, int minThreshold, int minRed, int minGreen, int minBlue, int maxThreshold, int maxRed, int maxGreen, int maxBlue)
{
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGB(animationId, minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	Fill all frames with the min RGB color where the animation color is less
	than the min threshold AND with the max RGB color where the animation is
	more than the max threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGBName(String path, int minThreshold, int minRed, int minGreen, int minBlue, int maxThreshold, int maxRed, int maxGreen, int maxBlue)
{
	ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBName(path.utf8().get_data(), minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsMinMaxAllFramesRGBNameD(String path, double minThreshold, double minRed, double minGreen, double minBlue, double maxThreshold, double maxRed, double maxGreen, double maxBlue)
{
	return ChromaAnimationAPI::FillThresholdColorsMinMaxAllFramesRGBNameD(path.utf8().get_data(), minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	Fill the specified frame with the min RGB color where the animation color
	is less than the min threshold AND with the max RGB color where the animation
	is more than the max threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColorsMinMaxRGB(int animationId, int frameId, int minThreshold, int minRed, int minGreen, int minBlue, int maxThreshold, int maxRed, int maxGreen, int maxBlue)
{
	ChromaAnimationAPI::FillThresholdColorsMinMaxRGB(animationId, frameId, minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	Fill the specified frame with the min RGB color where the animation color
	is less than the min threshold AND with the max RGB color where the animation
	is more than the max threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsMinMaxRGBName(String path, int frameId, int minThreshold, int minRed, int minGreen, int minBlue, int maxThreshold, int maxRed, int maxGreen, int maxBlue)
{
	ChromaAnimationAPI::FillThresholdColorsMinMaxRGBName(path.utf8().get_data(), frameId, minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsMinMaxRGBNameD(String path, double frameId, double minThreshold, double minRed, double minGreen, double minBlue, double maxThreshold, double maxRed, double maxGreen, double maxBlue)
{
	return ChromaAnimationAPI::FillThresholdColorsMinMaxRGBNameD(path.utf8().get_data(), frameId, minThreshold, minRed, minGreen, minBlue, maxThreshold, maxRed, maxGreen, maxBlue);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsName(String path, int frameId, int threshold, int color)
{
	ChromaAnimationAPI::FillThresholdColorsName(path.utf8().get_data(), frameId, threshold, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsNameD(String path, double frameId, double threshold, double color)
{
	return ChromaAnimationAPI::FillThresholdColorsNameD(path.utf8().get_data(), frameId, threshold, color);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdColorsRGB(int animationId, int frameId, int threshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdColorsRGB(animationId, frameId, threshold, red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdColorsRGBName(String path, int frameId, int threshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdColorsRGBName(path.utf8().get_data(), frameId, threshold, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdColorsRGBNameD(String path, double frameId, double threshold, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillThresholdColorsRGBNameD(path.utf8().get_data(), frameId, threshold, red, green, blue);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	RGB threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdRGBColorsAllFramesRGB(int animationId, int redThreshold, int greenThreshold, int blueThreshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdRGBColorsAllFramesRGB(animationId, redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	Fill all frames with RGB color where the animation color is less than the
	RGB threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdRGBColorsAllFramesRGBName(String path, int redThreshold, int greenThreshold, int blueThreshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdRGBColorsAllFramesRGBName(path.utf8().get_data(), redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdRGBColorsAllFramesRGBNameD(String path, double redThreshold, double greenThreshold, double blueThreshold, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillThresholdRGBColorsAllFramesRGBNameD(path.utf8().get_data(), redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillThresholdRGBColorsRGB(int animationId, int frameId, int redThreshold, int greenThreshold, int blueThreshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdRGBColorsRGB(animationId, frameId, redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is less
	than the RGB threshold. Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillThresholdRGBColorsRGBName(String path, int frameId, int redThreshold, int greenThreshold, int blueThreshold, int red, int green, int blue)
{
	ChromaAnimationAPI::FillThresholdRGBColorsRGBName(path.utf8().get_data(), frameId, redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillThresholdRGBColorsRGBNameD(String path, double frameId, double redThreshold, double greenThreshold, double blueThreshold, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillThresholdRGBColorsRGBNameD(path.utf8().get_data(), frameId, redThreshold, greenThreshold, blueThreshold, red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is zero.
	Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillZeroColor(int animationId, int frameId, int color)
{
	ChromaAnimationAPI::FillZeroColor(animationId, frameId, color);
}

/*
	Fill all frames with RGB color where the animation color is zero. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::FillZeroColorAllFrames(int animationId, int color)
{
	ChromaAnimationAPI::FillZeroColorAllFrames(animationId, color);
}

/*
	Fill all frames with RGB color where the animation color is zero. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::FillZeroColorAllFramesName(String path, int color)
{
	ChromaAnimationAPI::FillZeroColorAllFramesName(path.utf8().get_data(), color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillZeroColorAllFramesNameD(String path, double color)
{
	return ChromaAnimationAPI::FillZeroColorAllFramesNameD(path.utf8().get_data(), color);
}

/*
	Fill all frames with RGB color where the animation color is zero. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::FillZeroColorAllFramesRGB(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillZeroColorAllFramesRGB(animationId, red, green, blue);
}

/*
	Fill all frames with RGB color where the animation color is zero. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::FillZeroColorAllFramesRGBName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::FillZeroColorAllFramesRGBName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillZeroColorAllFramesRGBNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillZeroColorAllFramesRGBNameD(path.utf8().get_data(), red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is zero.
	Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillZeroColorName(String path, int frameId, int color)
{
	ChromaAnimationAPI::FillZeroColorName(path.utf8().get_data(), frameId, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillZeroColorNameD(String path, double frameId, double color)
{
	return ChromaAnimationAPI::FillZeroColorNameD(path.utf8().get_data(), frameId, color);
}

/*
	Fill the specified frame with RGB color where the animation color is zero.
	Animation is referenced by id.
*/
void godot::NodeChromaSDK::FillZeroColorRGB(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillZeroColorRGB(animationId, frameId, red, green, blue);
}

/*
	Fill the specified frame with RGB color where the animation color is zero.
	Animation is referenced by name.
*/
void godot::NodeChromaSDK::FillZeroColorRGBName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::FillZeroColorRGBName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::FillZeroColorRGBNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::FillZeroColorRGBNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	Get the animation color for a frame given the `1D` `led`. The `led` should
	be greater than or equal to 0 and less than the `MaxLeds`. Animation is
	referenced by id.
*/
int godot::NodeChromaSDK::Get1DColor(int animationId, int frameId, int led)
{
	return ChromaAnimationAPI::Get1DColor(animationId, frameId, led);
}

/*
	Get the animation color for a frame given the `1D` `led`. The `led` should
	be greater than or equal to 0 and less than the `MaxLeds`. Animation is
	referenced by name.
*/
int godot::NodeChromaSDK::Get1DColorName(String path, int frameId, int led)
{
	return ChromaAnimationAPI::Get1DColorName(path.utf8().get_data(), frameId, led);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::Get1DColorNameD(String path, double frameId, double led)
{
	return ChromaAnimationAPI::Get1DColorNameD(path.utf8().get_data(), frameId, led);
}

/*
	Get the animation color for a frame given the `2D` `row` and `column`. The
	`row` should be greater than or equal to 0 and less than the `MaxRow`.
	The `column` should be greater than or equal to 0 and less than the `MaxColumn`.
	Animation is referenced by id.
*/
int godot::NodeChromaSDK::Get2DColor(int animationId, int frameId, int row, int column)
{
	return ChromaAnimationAPI::Get2DColor(animationId, frameId, row, column);
}

/*
	Get the animation color for a frame given the `2D` `row` and `column`. The
	`row` should be greater than or equal to 0 and less than the `MaxRow`.
	The `column` should be greater than or equal to 0 and less than the `MaxColumn`.
	Animation is referenced by name.
*/
int godot::NodeChromaSDK::Get2DColorName(String path, int frameId, int row, int column)
{
	return ChromaAnimationAPI::Get2DColorName(path.utf8().get_data(), frameId, row, column);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::Get2DColorNameD(String path, double frameId, double row, double column)
{
	return ChromaAnimationAPI::Get2DColorNameD(path.utf8().get_data(), frameId, row, column);
}

/*
	Get the animation id for the named animation.
*/
int godot::NodeChromaSDK::GetAnimation(String name)
{
	return ChromaAnimationAPI::GetAnimation(name.utf8().get_data());
}

/*
	`PluginGetAnimationCount` will return the number of loaded animations.
*/
int godot::NodeChromaSDK::GetAnimationCount()
{
	return ChromaAnimationAPI::GetAnimationCount();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetAnimationD(String name)
{
	return ChromaAnimationAPI::GetAnimationD(name.utf8().get_data());
}

/*
	`PluginGetAnimationId` will return the `animationId` given the `index` of
	the loaded animation. The `index` is zero-based and less than the number
	returned by `PluginGetAnimationCount`. Use `PluginGetAnimationName` to
	get the name of the animation.
*/
int godot::NodeChromaSDK::GetAnimationId(int index)
{
	return ChromaAnimationAPI::GetAnimationId(index);
}

/*
	`PluginGetAnimationName` takes an `animationId` and returns the name of
	the animation of the `.chroma` animation file. If a name is not available
	then an empty string will be returned.
*/
const char* godot::NodeChromaSDK::GetAnimationName(int animationId)
{
	return ChromaAnimationAPI::GetAnimationName(animationId);
}

/*
	Get the current frame of the animation referenced by id.
*/
int godot::NodeChromaSDK::GetCurrentFrame(int animationId)
{
	return ChromaAnimationAPI::GetCurrentFrame(animationId);
}

/*
	Get the current frame of the animation referenced by name.
*/
int godot::NodeChromaSDK::GetCurrentFrameName(String path)
{
	return ChromaAnimationAPI::GetCurrentFrameName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetCurrentFrameNameD(String path)
{
	return ChromaAnimationAPI::GetCurrentFrameNameD(path.utf8().get_data());
}

/*
	Returns the `EChromaSDKDevice1DEnum` or `EChromaSDKDevice2DEnum` of a `Chroma`
	animation respective to the `deviceType`, as an integer upon success. Returns
	-1 upon failure.
*/
int godot::NodeChromaSDK::GetDevice(int animationId)
{
	return ChromaAnimationAPI::GetDevice(animationId);
}

/*
	Returns the `EChromaSDKDevice1DEnum` or `EChromaSDKDevice2DEnum` of a `Chroma`
	animation respective to the `deviceType`, as an integer upon success. Returns
	-1 upon failure.
*/
int godot::NodeChromaSDK::GetDeviceName(String path)
{
	return ChromaAnimationAPI::GetDeviceName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetDeviceNameD(String path)
{
	return ChromaAnimationAPI::GetDeviceNameD(path.utf8().get_data());
}

/*
	Returns the `EChromaSDKDeviceTypeEnum` of a `Chroma` animation as an integer
	upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetDeviceType(int animationId)
{
	return ChromaAnimationAPI::GetDeviceType(animationId);
}

/*
	Returns the `EChromaSDKDeviceTypeEnum` of a `Chroma` animation as an integer
	upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetDeviceTypeName(String path)
{
	return ChromaAnimationAPI::GetDeviceTypeName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetDeviceTypeNameD(String path)
{
	return ChromaAnimationAPI::GetDeviceTypeNameD(path.utf8().get_data());
}

/*
	Gets the frame colors and duration (in seconds) for a `Chroma` animation.
	The `color` is expected to be an array of the expected dimensions for the
	`deviceType/device`. The `length` parameter is the size of the `color`
	array. For `EChromaSDKDevice1DEnum` the array size should be `MAX LEDS`.
	For `EChromaSDKDevice2DEnum` the array size should be `MAX ROW` * `MAX
	COLUMN`. Returns the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetFrame(int animationId, int frameIndex, float* duration, int* colors, int length)
{
	return ChromaAnimationAPI::GetFrame(animationId, frameIndex, duration, colors, length);
}

/*
	Returns the frame count of a `Chroma` animation upon success. Returns -1
	upon failure.
*/
int godot::NodeChromaSDK::GetFrameCount(int animationId)
{
	return ChromaAnimationAPI::GetFrameCount(animationId);
}

/*
	Returns the frame count of a `Chroma` animation upon success. Returns -1
	upon failure.
*/
int godot::NodeChromaSDK::GetFrameCountName(String path)
{
	return ChromaAnimationAPI::GetFrameCountName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetFrameCountNameD(String path)
{
	return ChromaAnimationAPI::GetFrameCountNameD(path.utf8().get_data());
}

/*
	Get the color of an animation key for the given frame referenced by id.
*/
int godot::NodeChromaSDK::GetKeyColor(int animationId, int frameId, int rzkey)
{
	return ChromaAnimationAPI::GetKeyColor(animationId, frameId, rzkey);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetKeyColorD(String path, double frameId, double rzkey)
{
	return ChromaAnimationAPI::GetKeyColorD(path.utf8().get_data(), frameId, rzkey);
}

/*
	Get the color of an animation key for the given frame referenced by name.
*/
int godot::NodeChromaSDK::GetKeyColorName(String path, int frameId, int rzkey)
{
	return ChromaAnimationAPI::GetKeyColorName(path.utf8().get_data(), frameId, rzkey);
}

/*
	Returns `RZRESULT_SUCCESS` if the plugin has been initialized successfully.
	Returns `RZRESULT_DLL_NOT_FOUND` if core Chroma library is not found. Returns
	`RZRESULT_DLL_INVALID_SIGNATURE` if core Chroma library has an invalid
	signature.
*/
RZRESULT godot::NodeChromaSDK::GetLibraryLoadedState()
{
	return ChromaAnimationAPI::GetLibraryLoadedState();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetLibraryLoadedStateD()
{
	return ChromaAnimationAPI::GetLibraryLoadedStateD();
}

/*
	Returns the `MAX COLUMN` given the `EChromaSDKDevice2DEnum` device as an
	integer upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetMaxColumn(int device)
{
	return ChromaAnimationAPI::GetMaxColumn(device);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetMaxColumnD(double device)
{
	return ChromaAnimationAPI::GetMaxColumnD(device);
}

/*
	Returns the MAX LEDS given the `EChromaSDKDevice1DEnum` device as an integer
	upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetMaxLeds(int device)
{
	return ChromaAnimationAPI::GetMaxLeds(device);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetMaxLedsD(double device)
{
	return ChromaAnimationAPI::GetMaxLedsD(device);
}

/*
	Returns the `MAX ROW` given the `EChromaSDKDevice2DEnum` device as an integer
	upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::GetMaxRow(int device)
{
	return ChromaAnimationAPI::GetMaxRow(device);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetMaxRowD(double device)
{
	return ChromaAnimationAPI::GetMaxRowD(device);
}

/*
	`PluginGetPlayingAnimationCount` will return the number of playing animations.
*/
int godot::NodeChromaSDK::GetPlayingAnimationCount()
{
	return ChromaAnimationAPI::GetPlayingAnimationCount();
}

/*
	`PluginGetPlayingAnimationId` will return the `animationId` given the `index`
	of the playing animation. The `index` is zero-based and less than the number
	returned by `PluginGetPlayingAnimationCount`. Use `PluginGetAnimationName`
	to get the name of the animation.
*/
int godot::NodeChromaSDK::GetPlayingAnimationId(int index)
{
	return ChromaAnimationAPI::GetPlayingAnimationId(index);
}

/*
	Get the RGB color given red, green, and blue.
*/
int godot::NodeChromaSDK::GetRGB(int red, int green, int blue)
{
	return ChromaAnimationAPI::GetRGB(red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::GetRGBD(double red, double green, double blue)
{
	return ChromaAnimationAPI::GetRGBD(red, green, blue);
}

/*
	Check if the animation has loop enabled referenced by id.
*/
bool godot::NodeChromaSDK::HasAnimationLoop(int animationId)
{
	return ChromaAnimationAPI::HasAnimationLoop(animationId);
}

/*
	Check if the animation has loop enabled referenced by name.
*/
bool godot::NodeChromaSDK::HasAnimationLoopName(String path)
{
	return ChromaAnimationAPI::HasAnimationLoopName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::HasAnimationLoopNameD(String path)
{
	return ChromaAnimationAPI::HasAnimationLoopNameD(path.utf8().get_data());
}

/*
	Initialize the ChromaSDK. Zero indicates  success, otherwise failure. Many
	API methods auto initialize the ChromaSDK if not already initialized.
*/
RZRESULT godot::NodeChromaSDK::Init()
{
	return ChromaAnimationAPI::Init();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::InitD()
{
	return ChromaAnimationAPI::InitD();
}

/*
	Insert an animation delay by duplicating the frame by the delay number of
	times. Animation is referenced by id.
*/
void godot::NodeChromaSDK::InsertDelay(int animationId, int frameId, int delay)
{
	ChromaAnimationAPI::InsertDelay(animationId, frameId, delay);
}

/*
	Insert an animation delay by duplicating the frame by the delay number of
	times. Animation is referenced by name.
*/
void godot::NodeChromaSDK::InsertDelayName(String path, int frameId, int delay)
{
	ChromaAnimationAPI::InsertDelayName(path.utf8().get_data(), frameId, delay);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::InsertDelayNameD(String path, double frameId, double delay)
{
	return ChromaAnimationAPI::InsertDelayNameD(path.utf8().get_data(), frameId, delay);
}

/*
	Duplicate the source frame index at the target frame index. Animation is
	referenced by id.
*/
void godot::NodeChromaSDK::InsertFrame(int animationId, int sourceFrame, int targetFrame)
{
	ChromaAnimationAPI::InsertFrame(animationId, sourceFrame, targetFrame);
}

/*
	Duplicate the source frame index at the target frame index. Animation is
	referenced by name.
*/
void godot::NodeChromaSDK::InsertFrameName(String path, int sourceFrame, int targetFrame)
{
	ChromaAnimationAPI::InsertFrameName(path.utf8().get_data(), sourceFrame, targetFrame);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::InsertFrameNameD(String path, double sourceFrame, double targetFrame)
{
	return ChromaAnimationAPI::InsertFrameNameD(path.utf8().get_data(), sourceFrame, targetFrame);
}

/*
	Invert all the colors at the specified frame. Animation is referenced by
	id.
*/
void godot::NodeChromaSDK::InvertColors(int animationId, int frameId)
{
	ChromaAnimationAPI::InvertColors(animationId, frameId);
}

/*
	Invert all the colors for all frames. Animation is referenced by id.
*/
void godot::NodeChromaSDK::InvertColorsAllFrames(int animationId)
{
	ChromaAnimationAPI::InvertColorsAllFrames(animationId);
}

/*
	Invert all the colors for all frames. Animation is referenced by name.
*/
void godot::NodeChromaSDK::InvertColorsAllFramesName(String path)
{
	ChromaAnimationAPI::InvertColorsAllFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::InvertColorsAllFramesNameD(String path)
{
	return ChromaAnimationAPI::InvertColorsAllFramesNameD(path.utf8().get_data());
}

/*
	Invert all the colors at the specified frame. Animation is referenced by
	name.
*/
void godot::NodeChromaSDK::InvertColorsName(String path, int frameId)
{
	ChromaAnimationAPI::InvertColorsName(path.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::InvertColorsNameD(String path, double frameId)
{
	return ChromaAnimationAPI::InvertColorsNameD(path.utf8().get_data(), frameId);
}

/*
	Check if the animation is paused referenced by id.
*/
bool godot::NodeChromaSDK::IsAnimationPaused(int animationId)
{
	return ChromaAnimationAPI::IsAnimationPaused(animationId);
}

/*
	Check if the animation is paused referenced by name.
*/
bool godot::NodeChromaSDK::IsAnimationPausedName(String path)
{
	return ChromaAnimationAPI::IsAnimationPausedName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsAnimationPausedNameD(String path)
{
	return ChromaAnimationAPI::IsAnimationPausedNameD(path.utf8().get_data());
}

/*
	The editor dialog is a non-blocking modal window, this method returns true
	if the modal window is open, otherwise false.
*/
bool godot::NodeChromaSDK::IsDialogOpen()
{
	return ChromaAnimationAPI::IsDialogOpen();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsDialogOpenD()
{
	return ChromaAnimationAPI::IsDialogOpenD();
}

/*
	Returns true if the plugin has been initialized. Returns false if the plugin
	is uninitialized.
*/
bool godot::NodeChromaSDK::IsInitialized()
{
	return ChromaAnimationAPI::IsInitialized();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsInitializedD()
{
	return ChromaAnimationAPI::IsInitializedD();
}

/*
	If the method can be invoked the method returns true.
*/
bool godot::NodeChromaSDK::IsPlatformSupported()
{
	return ChromaAnimationAPI::IsPlatformSupported();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsPlatformSupportedD()
{
	return ChromaAnimationAPI::IsPlatformSupportedD();
}

/*
	`PluginIsPlayingName` automatically handles initializing the `ChromaSDK`.
	The named `.chroma` animation file will be automatically opened. The method
	will return whether the animation is playing or not. Animation is referenced
	by id.
*/
bool godot::NodeChromaSDK::IsPlaying(int animationId)
{
	return ChromaAnimationAPI::IsPlaying(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsPlayingD(double animationId)
{
	return ChromaAnimationAPI::IsPlayingD(animationId);
}

/*
	`PluginIsPlayingName` automatically handles initializing the `ChromaSDK`.
	The named `.chroma` animation file will be automatically opened. The method
	will return whether the animation is playing or not. Animation is referenced
	by name.
*/
bool godot::NodeChromaSDK::IsPlayingName(String path)
{
	return ChromaAnimationAPI::IsPlayingName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsPlayingNameD(String path)
{
	return ChromaAnimationAPI::IsPlayingNameD(path.utf8().get_data());
}

/*
	`PluginIsPlayingType` automatically handles initializing the `ChromaSDK`.
	If any animation is playing for the `deviceType` and `device` combination,
	the method will return true, otherwise false.
*/
bool godot::NodeChromaSDK::IsPlayingType(int deviceType, int device)
{
	return ChromaAnimationAPI::IsPlayingType(deviceType, device);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::IsPlayingTypeD(double deviceType, double device)
{
	return ChromaAnimationAPI::IsPlayingTypeD(deviceType, device);
}

/*
	Do a lerp math operation on a float.
*/
float godot::NodeChromaSDK::Lerp(float start, float end, float amt)
{
	return ChromaAnimationAPI::Lerp(start, end, amt);
}

/*
	Lerp from one color to another given t in the range 0.0 to 1.0.
*/
int godot::NodeChromaSDK::LerpColor(int from, int to, float t)
{
	return ChromaAnimationAPI::LerpColor(from, to, t);
}

/*
	Loads `Chroma` effects so that the animation can be played immediately.
	Returns the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::LoadAnimation(int animationId)
{
	return ChromaAnimationAPI::LoadAnimation(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::LoadAnimationD(double animationId)
{
	return ChromaAnimationAPI::LoadAnimationD(animationId);
}

/*
	Load the named animation.
*/
void godot::NodeChromaSDK::LoadAnimationName(String path)
{
	ChromaAnimationAPI::LoadAnimationName(path.utf8().get_data());
}

/*
	Load a composite set of animations.
*/
void godot::NodeChromaSDK::LoadComposite(String name)
{
	ChromaAnimationAPI::LoadComposite(name.utf8().get_data());
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color defaults to color. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::MakeBlankFrames(int animationId, int frameCount, float duration, int color)
{
	ChromaAnimationAPI::MakeBlankFrames(animationId, frameCount, duration, color);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color defaults to color. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::MakeBlankFramesName(String path, int frameCount, float duration, int color)
{
	ChromaAnimationAPI::MakeBlankFramesName(path.utf8().get_data(), frameCount, duration, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MakeBlankFramesNameD(String path, double frameCount, double duration, double color)
{
	return ChromaAnimationAPI::MakeBlankFramesNameD(path.utf8().get_data(), frameCount, duration, color);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color is random. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MakeBlankFramesRandom(int animationId, int frameCount, float duration)
{
	ChromaAnimationAPI::MakeBlankFramesRandom(animationId, frameCount, duration);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color is random black and white. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::MakeBlankFramesRandomBlackAndWhite(int animationId, int frameCount, float duration)
{
	ChromaAnimationAPI::MakeBlankFramesRandomBlackAndWhite(animationId, frameCount, duration);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color is random black and white. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::MakeBlankFramesRandomBlackAndWhiteName(String path, int frameCount, float duration)
{
	ChromaAnimationAPI::MakeBlankFramesRandomBlackAndWhiteName(path.utf8().get_data(), frameCount, duration);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MakeBlankFramesRandomBlackAndWhiteNameD(String path, double frameCount, double duration)
{
	return ChromaAnimationAPI::MakeBlankFramesRandomBlackAndWhiteNameD(path.utf8().get_data(), frameCount, duration);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color is random. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::MakeBlankFramesRandomName(String path, int frameCount, float duration)
{
	ChromaAnimationAPI::MakeBlankFramesRandomName(path.utf8().get_data(), frameCount, duration);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MakeBlankFramesRandomNameD(String path, double frameCount, double duration)
{
	return ChromaAnimationAPI::MakeBlankFramesRandomNameD(path.utf8().get_data(), frameCount, duration);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color defaults to color. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::MakeBlankFramesRGB(int animationId, int frameCount, float duration, int red, int green, int blue)
{
	ChromaAnimationAPI::MakeBlankFramesRGB(animationId, frameCount, duration, red, green, blue);
}

/*
	Make a blank animation for the length of the frame count. Frame duration
	defaults to the duration. The frame color defaults to color. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::MakeBlankFramesRGBName(String path, int frameCount, float duration, int red, int green, int blue)
{
	ChromaAnimationAPI::MakeBlankFramesRGBName(path.utf8().get_data(), frameCount, duration, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MakeBlankFramesRGBNameD(String path, double frameCount, double duration, double red, double green, double blue)
{
	return ChromaAnimationAPI::MakeBlankFramesRGBNameD(path.utf8().get_data(), frameCount, duration, red, green, blue);
}

/*
	Flips the color grid horizontally for all `Chroma` animation frames. Returns
	the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::MirrorHorizontally(int animationId)
{
	return ChromaAnimationAPI::MirrorHorizontally(animationId);
}

/*
	Flips the color grid vertically for all `Chroma` animation frames. This
	method has no effect for `EChromaSDKDevice1DEnum` devices. Returns the
	animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::MirrorVertically(int animationId)
{
	return ChromaAnimationAPI::MirrorVertically(animationId);
}

/*
	Multiply the color intensity with the lerp result from color 1 to color
	2 using the frame index divided by the frame count for the `t` parameter.
	Animation is referenced in id.
*/
void godot::NodeChromaSDK::MultiplyColorLerpAllFrames(int animationId, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyColorLerpAllFrames(animationId, color1, color2);
}

/*
	Multiply the color intensity with the lerp result from color 1 to color
	2 using the frame index divided by the frame count for the `t` parameter.
	Animation is referenced in name.
*/
void godot::NodeChromaSDK::MultiplyColorLerpAllFramesName(String path, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyColorLerpAllFramesName(path.utf8().get_data(), color1, color2);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyColorLerpAllFramesNameD(String path, double color1, double color2)
{
	return ChromaAnimationAPI::MultiplyColorLerpAllFramesNameD(path.utf8().get_data(), color1, color2);
}

/*
	Multiply all the colors in the frame by the intensity value. The valid the
	intensity range is from 0.0 to 255.0. RGB components are multiplied equally.
	An intensity of 0.5 would half the color value. Black colors in the frame
	will not be affected by this method.
*/
void godot::NodeChromaSDK::MultiplyIntensity(int animationId, int frameId, float intensity)
{
	ChromaAnimationAPI::MultiplyIntensity(animationId, frameId, intensity);
}

/*
	Multiply all the colors for all frames by the intensity value. The valid
	the intensity range is from 0.0 to 255.0. RGB components are multiplied
	equally. An intensity of 0.5 would half the color value. Black colors in
	the frame will not be affected by this method.
*/
void godot::NodeChromaSDK::MultiplyIntensityAllFrames(int animationId, float intensity)
{
	ChromaAnimationAPI::MultiplyIntensityAllFrames(animationId, intensity);
}

/*
	Multiply all the colors for all frames by the intensity value. The valid
	the intensity range is from 0.0 to 255.0. RGB components are multiplied
	equally. An intensity of 0.5 would half the color value. Black colors in
	the frame will not be affected by this method.
*/
void godot::NodeChromaSDK::MultiplyIntensityAllFramesName(String path, float intensity)
{
	ChromaAnimationAPI::MultiplyIntensityAllFramesName(path.utf8().get_data(), intensity);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityAllFramesNameD(String path, double intensity)
{
	return ChromaAnimationAPI::MultiplyIntensityAllFramesNameD(path.utf8().get_data(), intensity);
}

/*
	Multiply all frames by the RBG color intensity. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyIntensityAllFramesRGB(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGB(animationId, red, green, blue);
}

/*
	Multiply all frames by the RBG color intensity. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::MultiplyIntensityAllFramesRGBName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::MultiplyIntensityAllFramesRGBName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityAllFramesRGBNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::MultiplyIntensityAllFramesRGBNameD(path.utf8().get_data(), red, green, blue);
}

/*
	Multiply the specific frame by the RBG color intensity. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyIntensityColor(int animationId, int frameId, int color)
{
	ChromaAnimationAPI::MultiplyIntensityColor(animationId, frameId, color);
}

/*
	Multiply all frames by the RBG color intensity. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyIntensityColorAllFrames(int animationId, int color)
{
	ChromaAnimationAPI::MultiplyIntensityColorAllFrames(animationId, color);
}

/*
	Multiply all frames by the RBG color intensity. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::MultiplyIntensityColorAllFramesName(String path, int color)
{
	ChromaAnimationAPI::MultiplyIntensityColorAllFramesName(path.utf8().get_data(), color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityColorAllFramesNameD(String path, double color)
{
	return ChromaAnimationAPI::MultiplyIntensityColorAllFramesNameD(path.utf8().get_data(), color);
}

/*
	Multiply the specific frame by the RBG color intensity. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::MultiplyIntensityColorName(String path, int frameId, int color)
{
	ChromaAnimationAPI::MultiplyIntensityColorName(path.utf8().get_data(), frameId, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityColorNameD(String path, double frameId, double color)
{
	return ChromaAnimationAPI::MultiplyIntensityColorNameD(path.utf8().get_data(), frameId, color);
}

/*
	Multiply all the colors in the frame by the intensity value. The valid the
	intensity range is from 0.0 to 255.0. RGB components are multiplied equally.
	An intensity of 0.5 would half the color value. Black colors in the frame
	will not be affected by this method.
*/
void godot::NodeChromaSDK::MultiplyIntensityName(String path, int frameId, float intensity)
{
	ChromaAnimationAPI::MultiplyIntensityName(path.utf8().get_data(), frameId, intensity);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityNameD(String path, double frameId, double intensity)
{
	return ChromaAnimationAPI::MultiplyIntensityNameD(path.utf8().get_data(), frameId, intensity);
}

/*
	Multiply the specific frame by the RBG color intensity. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyIntensityRGB(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::MultiplyIntensityRGB(animationId, frameId, red, green, blue);
}

/*
	Multiply the specific frame by the RBG color intensity. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::MultiplyIntensityRGBName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::MultiplyIntensityRGBName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyIntensityRGBNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::MultiplyIntensityRGBNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	Multiply the specific frame by the color lerp result between color 1 and
	2 using the frame color value as the `t` value. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerp(int animationId, int frameId, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyNonZeroTargetColorLerp(animationId, frameId, color1, color2);
}

/*
	Multiply all frames by the color lerp result between color 1 and 2 using
	the frame color value as the `t` value. Animation is referenced by id.
*/
void godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFrames(int animationId, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFrames(animationId, color1, color2);
}

/*
	Multiply all frames by the color lerp result between color 1 and 2 using
	the frame color value as the `t` value. Animation is referenced by name.
*/
void godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesName(String path, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFramesName(path.utf8().get_data(), color1, color2);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesNameD(String path, double color1, double color2)
{
	return ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFramesNameD(path.utf8().get_data(), color1, color2);
}

/*
	Multiply the specific frame by the color lerp result between RGB 1 and 2
	using the frame color value as the `t` value. Animation is referenced by
	id.
*/
void godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGB(int animationId, int red1, int green1, int blue1, int red2, int green2, int blue2)
{
	ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFramesRGB(animationId, red1, green1, blue1, red2, green2, blue2);
}

/*
	Multiply the specific frame by the color lerp result between RGB 1 and 2
	using the frame color value as the `t` value. Animation is referenced by
	name.
*/
void godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGBName(String path, int red1, int green1, int blue1, int red2, int green2, int blue2)
{
	ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFramesRGBName(path.utf8().get_data(), red1, green1, blue1, red2, green2, blue2);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyNonZeroTargetColorLerpAllFramesRGBNameD(String path, double red1, double green1, double blue1, double red2, double green2, double blue2)
{
	return ChromaAnimationAPI::MultiplyNonZeroTargetColorLerpAllFramesRGBNameD(path.utf8().get_data(), red1, green1, blue1, red2, green2, blue2);
}

/*
	Multiply the specific frame by the color lerp result between color 1 and
	2 using the frame color value as the `t` value. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::MultiplyTargetColorLerp(int animationId, int frameId, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyTargetColorLerp(animationId, frameId, color1, color2);
}

/*
	Multiply all frames by the color lerp result between color 1 and 2 using
	the frame color value as the `t` value. Animation is referenced by id.
*/
void godot::NodeChromaSDK::MultiplyTargetColorLerpAllFrames(int animationId, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyTargetColorLerpAllFrames(animationId, color1, color2);
}

/*
	Multiply all frames by the color lerp result between color 1 and 2 using
	the frame color value as the `t` value. Animation is referenced by name.
*/
void godot::NodeChromaSDK::MultiplyTargetColorLerpAllFramesName(String path, int color1, int color2)
{
	ChromaAnimationAPI::MultiplyTargetColorLerpAllFramesName(path.utf8().get_data(), color1, color2);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyTargetColorLerpAllFramesNameD(String path, double color1, double color2)
{
	return ChromaAnimationAPI::MultiplyTargetColorLerpAllFramesNameD(path.utf8().get_data(), color1, color2);
}

/*
	Multiply all frames by the color lerp result between RGB 1 and 2 using the
	frame color value as the `t` value. Animation is referenced by id.
*/
void godot::NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGB(int animationId, int red1, int green1, int blue1, int red2, int green2, int blue2)
{
	ChromaAnimationAPI::MultiplyTargetColorLerpAllFramesRGB(animationId, red1, green1, blue1, red2, green2, blue2);
}

/*
	Multiply all frames by the color lerp result between RGB 1 and 2 using the
	frame color value as the `t` value. Animation is referenced by name.
*/
void godot::NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGBName(String path, int red1, int green1, int blue1, int red2, int green2, int blue2)
{
	ChromaAnimationAPI::MultiplyTargetColorLerpAllFramesRGBName(path.utf8().get_data(), red1, green1, blue1, red2, green2, blue2);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::MultiplyTargetColorLerpAllFramesRGBNameD(String path, double red1, double green1, double blue1, double red2, double green2, double blue2)
{
	return ChromaAnimationAPI::MultiplyTargetColorLerpAllFramesRGBNameD(path.utf8().get_data(), red1, green1, blue1, red2, green2, blue2);
}

/*
	Offset all colors in the frame using the RGB offset. Use the range of -255
	to 255 for red, green, and blue parameters. Negative values remove color.
	Positive values add color.
*/
void godot::NodeChromaSDK::OffsetColors(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetColors(animationId, frameId, red, green, blue);
}

/*
	Offset all colors for all frames using the RGB offset. Use the range of
	-255 to 255 for red, green, and blue parameters. Negative values remove
	color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetColorsAllFrames(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetColorsAllFrames(animationId, red, green, blue);
}

/*
	Offset all colors for all frames using the RGB offset. Use the range of
	-255 to 255 for red, green, and blue parameters. Negative values remove
	color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetColorsAllFramesName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetColorsAllFramesName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OffsetColorsAllFramesNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::OffsetColorsAllFramesNameD(path.utf8().get_data(), red, green, blue);
}

/*
	Offset all colors in the frame using the RGB offset. Use the range of -255
	to 255 for red, green, and blue parameters. Negative values remove color.
	Positive values add color.
*/
void godot::NodeChromaSDK::OffsetColorsName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetColorsName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OffsetColorsNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::OffsetColorsNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Offset a subset of colors in the frame using the RGB offset.
	Use the range of -255 to 255 for red, green, and blue parameters. Negative
	values remove color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetNonZeroColors(int animationId, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetNonZeroColors(animationId, frameId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Offset a subset of colors for all frames using the RGB offset.
	Use the range of -255 to 255 for red, green, and blue parameters. Negative
	values remove color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetNonZeroColorsAllFrames(int animationId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetNonZeroColorsAllFrames(animationId, red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Offset a subset of colors for all frames using the RGB offset.
	Use the range of -255 to 255 for red, green, and blue parameters. Negative
	values remove color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetNonZeroColorsAllFramesName(String path, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetNonZeroColorsAllFramesName(path.utf8().get_data(), red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OffsetNonZeroColorsAllFramesNameD(String path, double red, double green, double blue)
{
	return ChromaAnimationAPI::OffsetNonZeroColorsAllFramesNameD(path.utf8().get_data(), red, green, blue);
}

/*
	This method will only update colors in the animation that are not already
	set to black. Offset a subset of colors in the frame using the RGB offset.
	Use the range of -255 to 255 for red, green, and blue parameters. Negative
	values remove color. Positive values add color.
*/
void godot::NodeChromaSDK::OffsetNonZeroColorsName(String path, int frameId, int red, int green, int blue)
{
	ChromaAnimationAPI::OffsetNonZeroColorsName(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OffsetNonZeroColorsNameD(String path, double frameId, double red, double green, double blue)
{
	return ChromaAnimationAPI::OffsetNonZeroColorsNameD(path.utf8().get_data(), frameId, red, green, blue);
}

/*
	Opens a `Chroma` animation file so that it can be played. Returns an animation
	id >= 0 upon success. Returns -1 if there was a failure. The animation
	id is used in most of the API methods.
*/
int godot::NodeChromaSDK::OpenAnimation(String path)
{
	return ChromaAnimationAPI::OpenAnimation(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OpenAnimationD(String path)
{
	return ChromaAnimationAPI::OpenAnimationD(path.utf8().get_data());
}

/*
	Opens a `Chroma` animation data from memory so that it can be played. `Data`
	is a pointer to byte array of the loaded animation in memory. `Name` will
	be assigned to the animation when loaded. Returns an animation id >= 0
	upon success. Returns -1 if there was a failure. The animation id is used
	in most of the API methods.
*/
int godot::NodeChromaSDK::OpenAnimationFromMemory(const byte* data, String name)
{
	return ChromaAnimationAPI::OpenAnimationFromMemory(data, name.utf8().get_data());
}

/*
	Opens a `Chroma` animation file with the `.chroma` extension. Returns zero
	upon success. Returns -1 if there was a failure.
*/
int godot::NodeChromaSDK::OpenEditorDialog(String path)
{
	return ChromaAnimationAPI::OpenEditorDialog(path.utf8().get_data());
}

/*
	Open the named animation in the editor dialog and play the animation at
	start.
*/
int godot::NodeChromaSDK::OpenEditorDialogAndPlay(String path)
{
	return ChromaAnimationAPI::OpenEditorDialogAndPlay(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OpenEditorDialogAndPlayD(String path)
{
	return ChromaAnimationAPI::OpenEditorDialogAndPlayD(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OpenEditorDialogD(String path)
{
	return ChromaAnimationAPI::OpenEditorDialogD(path.utf8().get_data());
}

/*
	Sets the `duration` for all grames in the `Chroma` animation to the `duration`
	parameter. Returns the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::OverrideFrameDuration(int animationId, float duration)
{
	return ChromaAnimationAPI::OverrideFrameDuration(animationId, duration);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::OverrideFrameDurationD(double animationId, double duration)
{
	return ChromaAnimationAPI::OverrideFrameDurationD(animationId, duration);
}

/*
	Override the duration of all frames with the `duration` value. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::OverrideFrameDurationName(String path, float duration)
{
	ChromaAnimationAPI::OverrideFrameDurationName(path.utf8().get_data(), duration);
}

/*
	Pause the current animation referenced by id.
*/
void godot::NodeChromaSDK::PauseAnimation(int animationId)
{
	ChromaAnimationAPI::PauseAnimation(animationId);
}

/*
	Pause the current animation referenced by name.
*/
void godot::NodeChromaSDK::PauseAnimationName(String path)
{
	ChromaAnimationAPI::PauseAnimationName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PauseAnimationNameD(String path)
{
	return ChromaAnimationAPI::PauseAnimationNameD(path.utf8().get_data());
}

/*
	Plays the `Chroma` animation. This will load the animation, if not loaded
	previously. Returns the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::PlayAnimation(int animationId)
{
	return ChromaAnimationAPI::PlayAnimation(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PlayAnimationD(double animationId)
{
	return ChromaAnimationAPI::PlayAnimationD(animationId);
}

/*
	`PluginPlayAnimationFrame` automatically handles initializing the `ChromaSDK`.
	The method will play the animation given the `animationId` with looping
	`on` or `off` starting at the `frameId`.
*/
void godot::NodeChromaSDK::PlayAnimationFrame(int animationId, int frameId, bool loop)
{
	ChromaAnimationAPI::PlayAnimationFrame(animationId, frameId, loop);
}

/*
	`PluginPlayAnimationFrameName` automatically handles initializing the `ChromaSDK`.
	The named `.chroma` animation file will be automatically opened. The animation
	will play with looping `on` or `off` starting at the `frameId`.
*/
void godot::NodeChromaSDK::PlayAnimationFrameName(String path, int frameId, bool loop)
{
	ChromaAnimationAPI::PlayAnimationFrameName(path.utf8().get_data(), frameId, loop);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PlayAnimationFrameNameD(String path, double frameId, double loop)
{
	return ChromaAnimationAPI::PlayAnimationFrameNameD(path.utf8().get_data(), frameId, loop);
}

/*
	`PluginPlayAnimationLoop` automatically handles initializing the `ChromaSDK`.
	The method will play the animation given the `animationId` with looping
	`on` or `off`.
*/
void godot::NodeChromaSDK::PlayAnimationLoop(int animationId, bool loop)
{
	ChromaAnimationAPI::PlayAnimationLoop(animationId, loop);
}

/*
	`PluginPlayAnimationName` automatically handles initializing the `ChromaSDK`.
	The named `.chroma` animation file will be automatically opened. The animation
	will play with looping `on` or `off`.
*/
void godot::NodeChromaSDK::PlayAnimationName(String path, bool loop)
{
	ChromaAnimationAPI::PlayAnimationName(path.utf8().get_data(), loop);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PlayAnimationNameD(String path, double loop)
{
	return ChromaAnimationAPI::PlayAnimationNameD(path.utf8().get_data(), loop);
}

/*
	`PluginPlayComposite` automatically handles initializing the `ChromaSDK`.
	The named animation files for the `.chroma` set will be automatically opened.
	The set of animations will play with looping `on` or `off`.
*/
void godot::NodeChromaSDK::PlayComposite(String name, bool loop)
{
	ChromaAnimationAPI::PlayComposite(name.utf8().get_data(), loop);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PlayCompositeD(String name, double loop)
{
	return ChromaAnimationAPI::PlayCompositeD(name.utf8().get_data(), loop);
}

/*
	Displays the `Chroma` animation frame on `Chroma` hardware given the `frameIndex`.
	Returns the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::PreviewFrame(int animationId, int frameIndex)
{
	return ChromaAnimationAPI::PreviewFrame(animationId, frameIndex);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::PreviewFrameD(double animationId, double frameIndex)
{
	return ChromaAnimationAPI::PreviewFrameD(animationId, frameIndex);
}

/*
	Displays the `Chroma` animation frame on `Chroma` hardware given the `frameIndex`.
	Animaton is referenced by name.
*/
void godot::NodeChromaSDK::PreviewFrameName(String path, int frameIndex)
{
	ChromaAnimationAPI::PreviewFrameName(path.utf8().get_data(), frameIndex);
}

/*
	Reduce the frames of the animation by removing every nth element. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::ReduceFrames(int animationId, int n)
{
	ChromaAnimationAPI::ReduceFrames(animationId, n);
}

/*
	Reduce the frames of the animation by removing every nth element. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::ReduceFramesName(String path, int n)
{
	ChromaAnimationAPI::ReduceFramesName(path.utf8().get_data(), n);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::ReduceFramesNameD(String path, double n)
{
	return ChromaAnimationAPI::ReduceFramesNameD(path.utf8().get_data(), n);
}

/*
	Resets the `Chroma` animation to 1 blank frame. Returns the animation id
	upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::ResetAnimation(int animationId)
{
	return ChromaAnimationAPI::ResetAnimation(animationId);
}

/*
	Resume the animation with loop `ON` or `OFF` referenced by id.
*/
void godot::NodeChromaSDK::ResumeAnimation(int animationId, bool loop)
{
	ChromaAnimationAPI::ResumeAnimation(animationId, loop);
}

/*
	Resume the animation with loop `ON` or `OFF` referenced by name.
*/
void godot::NodeChromaSDK::ResumeAnimationName(String path, bool loop)
{
	ChromaAnimationAPI::ResumeAnimationName(path.utf8().get_data(), loop);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::ResumeAnimationNameD(String path, double loop)
{
	return ChromaAnimationAPI::ResumeAnimationNameD(path.utf8().get_data(), loop);
}

/*
	Reverse the animation frame order of the `Chroma` animation. Returns the
	animation id upon success. Returns -1 upon failure. Animation is referenced
	by id.
*/
int godot::NodeChromaSDK::Reverse(int animationId)
{
	return ChromaAnimationAPI::Reverse(animationId);
}

/*
	Reverse the animation frame order of the `Chroma` animation. Animation is
	referenced by id.
*/
void godot::NodeChromaSDK::ReverseAllFrames(int animationId)
{
	ChromaAnimationAPI::ReverseAllFrames(animationId);
}

/*
	Reverse the animation frame order of the `Chroma` animation. Animation is
	referenced by name.
*/
void godot::NodeChromaSDK::ReverseAllFramesName(String path)
{
	ChromaAnimationAPI::ReverseAllFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::ReverseAllFramesNameD(String path)
{
	return ChromaAnimationAPI::ReverseAllFramesNameD(path.utf8().get_data());
}

/*
	Save the animation referenced by id to the path specified.
*/
int godot::NodeChromaSDK::SaveAnimation(int animationId, String path)
{
	return ChromaAnimationAPI::SaveAnimation(animationId, path.utf8().get_data());
}

/*
	Save the named animation to the target path specified.
*/
int godot::NodeChromaSDK::SaveAnimationName(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::SaveAnimationName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Set the animation color for a frame given the `1D` `led`. The `led` should
	be greater than or equal to 0 and less than the `MaxLeds`. The animation
	is referenced by id.
*/
void godot::NodeChromaSDK::Set1DColor(int animationId, int frameId, int led, int color)
{
	ChromaAnimationAPI::Set1DColor(animationId, frameId, led, color);
}

/*
	Set the animation color for a frame given the `1D` `led`. The `led` should
	be greater than or equal to 0 and less than the `MaxLeds`. The animation
	is referenced by name.
*/
void godot::NodeChromaSDK::Set1DColorName(String path, int frameId, int led, int color)
{
	ChromaAnimationAPI::Set1DColorName(path.utf8().get_data(), frameId, led, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::Set1DColorNameD(String path, double frameId, double led, double color)
{
	return ChromaAnimationAPI::Set1DColorNameD(path.utf8().get_data(), frameId, led, color);
}

/*
	Set the animation color for a frame given the `2D` `row` and `column`. The
	`row` should be greater than or equal to 0 and less than the `MaxRow`.
	The `column` should be greater than or equal to 0 and less than the `MaxColumn`.
	The animation is referenced by id.
*/
void godot::NodeChromaSDK::Set2DColor(int animationId, int frameId, int row, int column, int color)
{
	ChromaAnimationAPI::Set2DColor(animationId, frameId, row, column, color);
}

/*
	Set the animation color for a frame given the `2D` `row` and `column`. The
	`row` should be greater than or equal to 0 and less than the `MaxRow`.
	The `column` should be greater than or equal to 0 and less than the `MaxColumn`.
	The animation is referenced by name.
*/
void godot::NodeChromaSDK::Set2DColorName(String path, int frameId, int row, int column, int color)
{
	ChromaAnimationAPI::Set2DColorName(path.utf8().get_data(), frameId, row, column, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::Set2DColorNameD(String path, double frameId, double rowColumnIndex, double color)
{
	return ChromaAnimationAPI::Set2DColorNameD(path.utf8().get_data(), frameId, rowColumnIndex, color);
}

/*
	When custom color is set, the custom key mode will be used. The animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetChromaCustomColorAllFrames(int animationId)
{
	ChromaAnimationAPI::SetChromaCustomColorAllFrames(animationId);
}

/*
	When custom color is set, the custom key mode will be used. The animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetChromaCustomColorAllFramesName(String path)
{
	ChromaAnimationAPI::SetChromaCustomColorAllFramesName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetChromaCustomColorAllFramesNameD(String path)
{
	return ChromaAnimationAPI::SetChromaCustomColorAllFramesNameD(path.utf8().get_data());
}

/*
	Set the Chroma custom key color flag on all frames. `True` changes the layout
	from grid to key. `True` changes the layout from key to grid. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetChromaCustomFlag(int animationId, bool flag)
{
	ChromaAnimationAPI::SetChromaCustomFlag(animationId, flag);
}

/*
	Set the Chroma custom key color flag on all frames. `True` changes the layout
	from grid to key. `True` changes the layout from key to grid. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetChromaCustomFlagName(String path, bool flag)
{
	ChromaAnimationAPI::SetChromaCustomFlagName(path.utf8().get_data(), flag);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetChromaCustomFlagNameD(String path, double flag)
{
	return ChromaAnimationAPI::SetChromaCustomFlagNameD(path.utf8().get_data(), flag);
}

/*
	Set the current frame of the animation referenced by id.
*/
void godot::NodeChromaSDK::SetCurrentFrame(int animationId, int frameId)
{
	ChromaAnimationAPI::SetCurrentFrame(animationId, frameId);
}

/*
	Set the current frame of the animation referenced by name.
*/
void godot::NodeChromaSDK::SetCurrentFrameName(String path, int frameId)
{
	ChromaAnimationAPI::SetCurrentFrameName(path.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetCurrentFrameNameD(String path, double frameId)
{
	return ChromaAnimationAPI::SetCurrentFrameNameD(path.utf8().get_data(), frameId);
}

/*
	Changes the `deviceType` and `device` of a `Chroma` animation. If the device
	is changed, the `Chroma` animation will be reset with 1 blank frame. Returns
	the animation id upon success. Returns -1 upon failure.
*/
int godot::NodeChromaSDK::SetDevice(int animationId, int deviceType, int device)
{
	return ChromaAnimationAPI::SetDevice(animationId, deviceType, device);
}

/*
	SetEffect will display the referenced effect id.
*/
RZRESULT godot::NodeChromaSDK::SetEffect(const ChromaSDK::FChromaSDKGuid& effectId)
{
	return ChromaAnimationAPI::SetEffect(effectId);
}

/*
	When the idle animation is used, the named animation will play when no other
	animations are playing. Reference the animation by id.
*/
void godot::NodeChromaSDK::SetIdleAnimation(int animationId)
{
	ChromaAnimationAPI::SetIdleAnimation(animationId);
}

/*
	When the idle animation is used, the named animation will play when no other
	animations are playing. Reference the animation by name.
*/
void godot::NodeChromaSDK::SetIdleAnimationName(String path)
{
	ChromaAnimationAPI::SetIdleAnimationName(path.utf8().get_data());
}

/*
	Set animation key to a static color for the given frame.
*/
void godot::NodeChromaSDK::SetKeyColor(int animationId, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyColor(animationId, frameId, rzkey, color);
}

/*
	Set the key to the specified key color for all frames. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::SetKeyColorAllFrames(int animationId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyColorAllFrames(animationId, rzkey, color);
}

/*
	Set the key to the specified key color for all frames. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::SetKeyColorAllFramesName(String path, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyColorAllFramesName(path.utf8().get_data(), rzkey, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyColorAllFramesNameD(String path, double rzkey, double color)
{
	return ChromaAnimationAPI::SetKeyColorAllFramesNameD(path.utf8().get_data(), rzkey, color);
}

/*
	Set the key to the specified key color for all frames. Animation is referenced
	by id.
*/
void godot::NodeChromaSDK::SetKeyColorAllFramesRGB(int animationId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyColorAllFramesRGB(animationId, rzkey, red, green, blue);
}

/*
	Set the key to the specified key color for all frames. Animation is referenced
	by name.
*/
void godot::NodeChromaSDK::SetKeyColorAllFramesRGBName(String path, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyColorAllFramesRGBName(path.utf8().get_data(), rzkey, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyColorAllFramesRGBNameD(String path, double rzkey, double red, double green, double blue)
{
	return ChromaAnimationAPI::SetKeyColorAllFramesRGBNameD(path.utf8().get_data(), rzkey, red, green, blue);
}

/*
	Set animation key to a static color for the given frame.
*/
void godot::NodeChromaSDK::SetKeyColorName(String path, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyColorName(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyColorNameD(String path, double frameId, double rzkey, double color)
{
	return ChromaAnimationAPI::SetKeyColorNameD(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	Set the key to the specified key color for the specified frame. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetKeyColorRGB(int animationId, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyColorRGB(animationId, frameId, rzkey, red, green, blue);
}

/*
	Set the key to the specified key color for the specified frame. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetKeyColorRGBName(String path, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyColorRGBName(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyColorRGBNameD(String path, double frameId, double rzkey, double red, double green, double blue)
{
	return ChromaAnimationAPI::SetKeyColorRGBNameD(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	Set animation key to a static color for the given frame if the existing
	color is not already black.
*/
void godot::NodeChromaSDK::SetKeyNonZeroColor(int animationId, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyNonZeroColor(animationId, frameId, rzkey, color);
}

/*
	Set animation key to a static color for the given frame if the existing
	color is not already black.
*/
void godot::NodeChromaSDK::SetKeyNonZeroColorName(String path, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyNonZeroColorName(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyNonZeroColorNameD(String path, double frameId, double rzkey, double color)
{
	return ChromaAnimationAPI::SetKeyNonZeroColorNameD(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	Set the key to the specified key color for the specified frame where color
	is not black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeyNonZeroColorRGB(int animationId, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyNonZeroColorRGB(animationId, frameId, rzkey, red, green, blue);
}

/*
	Set the key to the specified key color for the specified frame where color
	is not black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeyNonZeroColorRGBName(String path, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyNonZeroColorRGBName(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyNonZeroColorRGBNameD(String path, double frameId, double rzkey, double red, double green, double blue)
{
	return ChromaAnimationAPI::SetKeyNonZeroColorRGBNameD(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	Set an array of animation keys to a static color for the given frame. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysColor(int animationId, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColor(animationId, frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysColorAllFrames(int animationId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorAllFrames(animationId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysColorAllFramesName(String path, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorAllFramesName(path.utf8().get_data(), ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysColorAllFramesRGB(int animationId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorAllFramesRGB(animationId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysColorAllFramesRGBName(String path, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorAllFramesRGBName(path.utf8().get_data(), ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame.
*/
void godot::NodeChromaSDK::SetKeysColorName(String path, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame. Animation
	is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysColorRGB(int animationId, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorRGB(animationId, frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame. Animation
	is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysColorRGBName(String path, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysColorRGBName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame if
	the existing color is not already black.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColor(int animationId, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColor(animationId, frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is not black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColorAllFrames(int animationId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColorAllFrames(animationId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames if the existing
	color is not already black. Reference animation by name.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColorAllFramesName(String path, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColorAllFramesName(path.utf8().get_data(), ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame if
	the existing color is not already black. Reference animation by name.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColorName(String path, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColorName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is not black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColorRGB(int animationId, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColorRGB(animationId, frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is not black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysNonZeroColorRGBName(String path, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysNonZeroColorRGBName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysZeroColor(int animationId, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColor(animationId, frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames where the
	color is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysZeroColorAllFrames(int animationId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorAllFrames(animationId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames where the
	color is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysZeroColorAllFramesName(String path, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorAllFramesName(path.utf8().get_data(), ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames where the
	color is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysZeroColorAllFramesRGB(int animationId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorAllFramesRGB(animationId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for all frames where the
	color is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysZeroColorAllFramesRGBName(String path, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorAllFramesRGBName(path.utf8().get_data(), ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysZeroColorName(String path, int frameId, Array rzkeys, int keyCount, int color)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, color);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeysZeroColorRGB(int animationId, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorRGB(animationId, frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set an array of animation keys to a static color for the given frame where
	the color is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeysZeroColorRGBName(String path, int frameId, Array rzkeys, int keyCount, int red, int green, int blue)
{
	if (rzkeys.size())
	{
		int* ptrRzkeys = new int[rzkeys.size()];
		for (int i = 0; i < rzkeys.size(); ++i)
		{
			ptrRzkeys[i] = (int)rzkeys[i];
		}
		ChromaAnimationAPI::SetKeysZeroColorRGBName(path.utf8().get_data(), frameId, ptrRzkeys, keyCount, red, green, blue);
		delete[] ptrRzkeys;
	}
}

/*
	Set animation key to a static color for the given frame where the color
	is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeyZeroColor(int animationId, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyZeroColor(animationId, frameId, rzkey, color);
}

/*
	Set animation key to a static color for the given frame where the color
	is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeyZeroColorName(String path, int frameId, int rzkey, int color)
{
	ChromaAnimationAPI::SetKeyZeroColorName(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyZeroColorNameD(String path, double frameId, double rzkey, double color)
{
	return ChromaAnimationAPI::SetKeyZeroColorNameD(path.utf8().get_data(), frameId, rzkey, color);
}

/*
	Set animation key to a static color for the given frame where the color
	is black. Animation is referenced by id.
*/
void godot::NodeChromaSDK::SetKeyZeroColorRGB(int animationId, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyZeroColorRGB(animationId, frameId, rzkey, red, green, blue);
}

/*
	Set animation key to a static color for the given frame where the color
	is black. Animation is referenced by name.
*/
void godot::NodeChromaSDK::SetKeyZeroColorRGBName(String path, int frameId, int rzkey, int red, int green, int blue)
{
	ChromaAnimationAPI::SetKeyZeroColorRGBName(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SetKeyZeroColorRGBNameD(String path, double frameId, double rzkey, double red, double green, double blue)
{
	return ChromaAnimationAPI::SetKeyZeroColorRGBNameD(path.utf8().get_data(), frameId, rzkey, red, green, blue);
}

/*
	Invokes the setup for a debug logging callback so that `stdout` is redirected
	to the callback. This is used by `Unity` so that debug messages can appear
	in the console window.
*/
void godot::NodeChromaSDK::SetLogDelegate(DebugLogPtr fp)
{
	ChromaAnimationAPI::SetLogDelegate(fp);
}

/*
	`PluginStaticColor` sets the target device to the static color.
*/
void godot::NodeChromaSDK::StaticColor(int deviceType, int device, int color)
{
	ChromaAnimationAPI::StaticColor(deviceType, device, color);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::StaticColorD(double deviceType, double device, double color)
{
	return ChromaAnimationAPI::StaticColorD(deviceType, device, color);
}

/*
	`PluginStopAll` will automatically stop all animations that are playing.
*/
void godot::NodeChromaSDK::StopAll()
{
	ChromaAnimationAPI::StopAll();
}

/*
	Stops animation playback if in progress. Returns the animation id upon success.
	Returns -1 upon failure.
*/
int godot::NodeChromaSDK::StopAnimation(int animationId)
{
	return ChromaAnimationAPI::StopAnimation(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::StopAnimationD(double animationId)
{
	return ChromaAnimationAPI::StopAnimationD(animationId);
}

/*
	`PluginStopAnimationName` automatically handles initializing the `ChromaSDK`.
	The named `.chroma` animation file will be automatically opened. The animation
	will stop if playing.
*/
void godot::NodeChromaSDK::StopAnimationName(String path)
{
	ChromaAnimationAPI::StopAnimationName(path.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::StopAnimationNameD(String path)
{
	return ChromaAnimationAPI::StopAnimationNameD(path.utf8().get_data());
}

/*
	`PluginStopAnimationType` automatically handles initializing the `ChromaSDK`.
	If any animation is playing for the `deviceType` and `device` combination,
	it will be stopped.
*/
void godot::NodeChromaSDK::StopAnimationType(int deviceType, int device)
{
	ChromaAnimationAPI::StopAnimationType(deviceType, device);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::StopAnimationTypeD(double deviceType, double device)
{
	return ChromaAnimationAPI::StopAnimationTypeD(deviceType, device);
}

/*
	`PluginStopComposite` automatically handles initializing the `ChromaSDK`.
	The named animation files for the `.chroma` set will be automatically opened.
	The set of animations will be stopped if playing.
*/
void godot::NodeChromaSDK::StopComposite(String name)
{
	ChromaAnimationAPI::StopComposite(name.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::StopCompositeD(String name)
{
	return ChromaAnimationAPI::StopCompositeD(name.utf8().get_data());
}

/*
	Subtract the source color from the target color for all frames where the
	target color is not black. Source and target are referenced by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Subtract the source color from the target color for all frames where the
	target color is not black. Source and target are referenced by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Subtract the source color from the target color for all frames where the
	target color is not black starting at offset for the length of the source.
	Source and target are referenced by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Subtract the source color from the target color for all frames where the
	target color is not black starting at offset for the length of the source.
	Source and target are referenced by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::SubtractNonZeroAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Subtract the source color from the target where color is not black for the
	source frame and target offset frame, reference source and target by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Subtract the source color from the target where color is not black for the
	source frame and target offset frame, reference source and target by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::SubtractNonZeroAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Subtract the source color from the target color where the target color is
	not black for all frames. Reference source and target by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFrames(int sourceAnimationId, int targetAnimationId)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFrames(sourceAnimationId, targetAnimationId);
}

/*
	Subtract the source color from the target color where the target color is
	not black for all frames. Reference source and target by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesName(String sourceAnimation, String targetAnimation)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFramesName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesNameD(String sourceAnimation, String targetAnimation)
{
	return ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFramesNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data());
}

/*
	Subtract the source color from the target color where the target color is
	not black for all frames starting at the target offset for the length of
	the source. Reference source and target by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffset(int sourceAnimationId, int targetAnimationId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFramesOffset(sourceAnimationId, targetAnimationId, offset);
}

/*
	Subtract the source color from the target color where the target color is
	not black for all frames starting at the target offset for the length of
	the source. Reference source and target by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffsetName(String sourceAnimation, String targetAnimation, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFramesOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysAllFramesOffsetNameD(String sourceAnimation, String targetAnimation, double offset)
{
	return ChromaAnimationAPI::SubtractNonZeroTargetAllKeysAllFramesOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), offset);
}

/*
	Subtract the source color from the target color where the target color is
	not black from the source frame to the target offset frame. Reference source
	and target by id.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysOffset(int sourceAnimationId, int targetAnimationId, int frameId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysOffset(sourceAnimationId, targetAnimationId, frameId, offset);
}

/*
	Subtract the source color from the target color where the target color is
	not black from the source frame to the target offset frame. Reference source
	and target by name.
*/
void godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysOffsetName(String sourceAnimation, String targetAnimation, int frameId, int offset)
{
	ChromaAnimationAPI::SubtractNonZeroTargetAllKeysOffsetName(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::SubtractNonZeroTargetAllKeysOffsetNameD(String sourceAnimation, String targetAnimation, double frameId, double offset)
{
	return ChromaAnimationAPI::SubtractNonZeroTargetAllKeysOffsetNameD(sourceAnimation.utf8().get_data(), targetAnimation.utf8().get_data(), frameId, offset);
}

/*
	Trim the end of the animation. The length of the animation will be the lastFrameId
	+ 1. Reference the animation by id.
*/
void godot::NodeChromaSDK::TrimEndFrames(int animationId, int lastFrameId)
{
	ChromaAnimationAPI::TrimEndFrames(animationId, lastFrameId);
}

/*
	Trim the end of the animation. The length of the animation will be the lastFrameId
	+ 1. Reference the animation by name.
*/
void godot::NodeChromaSDK::TrimEndFramesName(String path, int lastFrameId)
{
	ChromaAnimationAPI::TrimEndFramesName(path.utf8().get_data(), lastFrameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::TrimEndFramesNameD(String path, double lastFrameId)
{
	return ChromaAnimationAPI::TrimEndFramesNameD(path.utf8().get_data(), lastFrameId);
}

/*
	Remove the frame from the animation. Reference animation by id.
*/
void godot::NodeChromaSDK::TrimFrame(int animationId, int frameId)
{
	ChromaAnimationAPI::TrimFrame(animationId, frameId);
}

/*
	Remove the frame from the animation. Reference animation by name.
*/
void godot::NodeChromaSDK::TrimFrameName(String path, int frameId)
{
	ChromaAnimationAPI::TrimFrameName(path.utf8().get_data(), frameId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::TrimFrameNameD(String path, double frameId)
{
	return ChromaAnimationAPI::TrimFrameNameD(path.utf8().get_data(), frameId);
}

/*
	Trim the start of the animation starting at frame 0 for the number of frames.
	Reference the animation by id.
*/
void godot::NodeChromaSDK::TrimStartFrames(int animationId, int numberOfFrames)
{
	ChromaAnimationAPI::TrimStartFrames(animationId, numberOfFrames);
}

/*
	Trim the start of the animation starting at frame 0 for the number of frames.
	Reference the animation by name.
*/
void godot::NodeChromaSDK::TrimStartFramesName(String path, int numberOfFrames)
{
	ChromaAnimationAPI::TrimStartFramesName(path.utf8().get_data(), numberOfFrames);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::TrimStartFramesNameD(String path, double numberOfFrames)
{
	return ChromaAnimationAPI::TrimStartFramesNameD(path.utf8().get_data(), numberOfFrames);
}

/*
	Uninitializes the `ChromaSDK`. Returns 0 upon success. Returns -1 upon failure.
*/
RZRESULT godot::NodeChromaSDK::Uninit()
{
	return ChromaAnimationAPI::Uninit();
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::UninitD()
{
	return ChromaAnimationAPI::UninitD();
}

/*
	Unloads `Chroma` effects to free up resources. Returns the animation id
	upon success. Returns -1 upon failure. Reference the animation by id.
*/
int godot::NodeChromaSDK::UnloadAnimation(int animationId)
{
	return ChromaAnimationAPI::UnloadAnimation(animationId);
}

/*
	D suffix for limited data types.
*/
double godot::NodeChromaSDK::UnloadAnimationD(double animationId)
{
	return ChromaAnimationAPI::UnloadAnimationD(animationId);
}

/*
	Unload the animation effects. Reference the animation by name.
*/
void godot::NodeChromaSDK::UnloadAnimationName(String path)
{
	ChromaAnimationAPI::UnloadAnimationName(path.utf8().get_data());
}

/*
	Unload the the composite set of animation effects. Reference the animation
	by name.
*/
void godot::NodeChromaSDK::UnloadComposite(String name)
{
	ChromaAnimationAPI::UnloadComposite(name.utf8().get_data());
}

/*
	Updates the `frameIndex` of the `Chroma` animation and sets the `duration`
	(in seconds). The `color` is expected to be an array of the dimensions
	for the `deviceType/device`. The `length` parameter is the size of the
	`color` array. For `EChromaSDKDevice1DEnum` the array size should be `MAX
	LEDS`. For `EChromaSDKDevice2DEnum` the array size should be `MAX ROW`
	* `MAX COLUMN`. Returns the animation id upon success. Returns -1 upon
	failure.
*/
int godot::NodeChromaSDK::UpdateFrame(int animationId, int frameIndex, float duration, int* colors, int length)
{
	return ChromaAnimationAPI::UpdateFrame(animationId, frameIndex, duration, colors, length);
}

/*
	When the idle animation flag is true, when no other animations are playing,
	the idle animation will be used. The idle animation will not be affected
	by the API calls to PluginIsPlaying, PluginStopAnimationType, PluginGetPlayingAnimationId,
	and PluginGetPlayingAnimationCount. Then the idle animation flag is false,
	the idle animation is disabled. `Device` uses `EChromaSDKDeviceEnum` enums.
*/
void godot::NodeChromaSDK::UseIdleAnimation(int device, bool flag)
{
	ChromaAnimationAPI::UseIdleAnimation(device, flag);
}

/*
	Set idle animation flag for all devices.
*/
void godot::NodeChromaSDK::UseIdleAnimations(bool flag)
{
	ChromaAnimationAPI::UseIdleAnimations(flag);
}

/*
	Set preloading animation flag, which is set to true by default. Reference
	animation by id.
*/
void godot::NodeChromaSDK::UsePreloading(int animationId, bool flag)
{
	ChromaAnimationAPI::UsePreloading(animationId, flag);
}

/*
	Set preloading animation flag, which is set to true by default. Reference
	animation by name.
*/
void godot::NodeChromaSDK::UsePreloadingName(String path, bool flag)
{
	ChromaAnimationAPI::UsePreloadingName(path.utf8().get_data(), flag);
}

#pragma endregion
